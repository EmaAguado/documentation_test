{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Inicio","text":"GwaIO <p>Potencia tu Pipeline</p> User Guide Dev Guide <p></p> <p></p> <p>GwaIO es una aplicaci\u00f3n de escritorio dise\u00f1ada para optimizar y simplificar la producci\u00f3n audiovisual a trav\u00e9s de potentes automatizaciones.</p> <p></p> <p>GwaIO act\u00faa como un puente inteligente entre la estaci\u00f3n de trabajo del artista, el servidor compartido y la base de datos del proyecto. Esto se traduce en un flujo de trabajo m\u00e1s \u00e1gil y eficiente, minimizando errores humanos y facilitando tareas cotidianas como:</p> <p></p> <p></p> <ul> <li>Creaci\u00f3n de ficheros con el naming convention adecuado.</li> <li>Subida y gesti\u00f3n de archivos en servidor y base de datos.</li> <li>Exportaci\u00f3n y guardado de ficheros de forma consistente. </li> </ul>"},{"location":"#beneficios-clave-de-gwaio","title":"Beneficios Clave de GwaIO:","text":"<ul> <li> <p> Aumento de la Productividad</p> <p>Trabaja m\u00e1s r\u00e1pido gracias a la automatizaci\u00f3n de tareas repetitivas y la simplificaci\u00f3n del flujo de trabajo. GwaIO permite integrar herramientas y scripts que agilizan las tareas repetitivas.</p> </li> <li> <p> Reducci\u00f3n de Errores</p> <p>Minimiza el error humano al automatizar procesos cr\u00edticos, garantizando resultados consistentes y de alta calidad.</p> </li> <li> <p> Control de Producci\u00f3n Mejorado</p> <p>Asegura que todo el material producido cumpla con los est\u00e1ndares establecidos y se almacene correctamente.</p> </li> <li> <p> Reducci\u00f3n de Costes</p> <p>Integra utilidades que a menudo requieren software externo, como la sincronizaci\u00f3n de archivos local/servidor, reduciendo licencias y gastos operativos.</p> </li> </ul> <p></p>"},{"location":"#como-funciona-gwaio-en-la-practica","title":"\u00bfC\u00f3mo funciona GwaIO en la pr\u00e1ctica?","text":"<p>Se presenta a los artistas con una interfaz intuitiva, una lista clara de tareas pendientes. Adem\u00e1s, facilita la generaci\u00f3n de nuevos ficheros mediante la automatizaci\u00f3n de:</p> <ul> <li>Nomenclatura de archivos.</li> <li>Recopilaci\u00f3n autom\u00e1tica de material de entrada de tareas previas.</li> <li>Publicaci\u00f3n eficiente de nuevas versiones en la base de datos.</li> </ul> <p>Recopilacion de archivos de tarea previa &lt; sincronizado de ficheros &lt; Creaci\u00f3n de archivo de version con naming correcto</p> <p></p>"},{"location":"#herramientas-integradas","title":"Herramientas integradas","text":"<p>Unifica y controla tu pipeline con GwaIO. Integra m\u00faltiples DCC de manera robusta y flexible. La arquitectura modular de GwaIO facilita la incorporaci\u00f3n de cualquier software, adapt\u00e1ndose completamente a tus necesidades.</p> <p></p> Maya Nuke Deadline FPT Substance Photoshop"},{"location":"#explora-la-documentacion","title":"Explora la Documentaci\u00f3n:","text":"<p>A lo largo de esta documentaci\u00f3n, profundizaremos en cada una de estas funcionalidades y te guiaremos para sacar el m\u00e1ximo provecho de GwaIO en tu pipeline de producci\u00f3n 3D. Comienza a explorar aqu\u00ed </p>"},{"location":"login/","title":"Login","text":"Login Incorrect username or password."},{"location":"dev/home/","title":"Introducci\u00f3n","text":""},{"location":"dev/home/#welcome-to-gwaiopublisher-documentation","title":"Welcome to GwaIO\u2011Publisher documentation","text":""},{"location":"dev/home/#modulos","title":"M\u00f3dulos","text":"<ul> <li>addon_a</li> </ul>"},{"location":"dev/home/#indices-y-tablas","title":"\u00cdndices y tablas","text":"<ul> <li>Usa la barra de b\u00fasqueda para localizar contenidos. </li> </ul>"},{"location":"dev/publisher/core/","title":"core","text":""},{"location":"dev/publisher/core/#core_1","title":"<code>core</code>","text":""},{"location":"dev/publisher/core/#core","title":"core","text":"<p>Classes:</p> <ul> <li> <code>Check</code>           \u2013            </li> <li> <code>Collect</code>           \u2013            <p>A class representing the file collection process.</p> </li> <li> <code>Context</code>           \u2013            <p>A shared context object for storing and accessing data across different processes.</p> </li> <li> <code>ErrorProcess</code>           \u2013            <p>Class to represent an error that occurs during process execution.</p> </li> <li> <code>Extract</code>           \u2013            <p>A class representing the file extraction process.</p> </li> <li> <code>Manager</code>           \u2013            <p>Manager class that manages the registration and execution</p> </li> <li> <code>Process</code>           \u2013            <pre><code>Abstract base class for all processes in the task publishing pipeline.\n</code></pre> </li> <li> <code>Push</code>           \u2013            <p>A class representing the process to push data to the database.</p> </li> <li> <code>StatusProcess</code>           \u2013            <p>Enum-like class representing the status of a process.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>log_execution</code>             \u2013              <p>Decorator to log the execution of process methods.</p> </li> </ul>"},{"location":"dev/publisher/core/#core.Check","title":"Check","text":"<pre><code>Check(manager: Manager)\n</code></pre> <p>Methods:</p> <ul> <li> <code>add_callback</code>             \u2013              <p>Adds a callback function to be executed after the process finishes.</p> </li> <li> <code>add_error</code>             \u2013              <p>Adds an error to the list of errors.</p> </li> <li> <code>fix_method</code>             \u2013              <p>Provides a method to fix issues detected by the check.</p> </li> <li> <code>process</code>             \u2013              <p>The core logic of the process. This method should be implemented by subclasses with specific logic for the process.</p> </li> <li> <code>set_status</code>             \u2013              <p>Sets the status of the process.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>callbacks</code>               (<code>Dict[Type[Callback], Callable]</code>)           \u2013            <p>Returns the dict of registered callbacks.</p> </li> <li> <code>context</code>               (<code>Context</code>)           \u2013            <p>Returns the shared context.</p> </li> <li> <code>errors</code>               (<code>List[ErrorProcess]</code>)           \u2013            <p>Returns the list of errors encountered during execution.</p> </li> <li> <code>status</code>               (<code>StatusProcess</code>)           \u2013            <p>Returns the current status of the process.</p> </li> </ul>"},{"location":"dev/publisher/core/#core.Check.callbacks","title":"callbacks  <code>property</code>","text":"<pre><code>callbacks: Dict[Type[Callback], Callable]\n</code></pre> <p>Returns the dict of registered callbacks.</p>"},{"location":"dev/publisher/core/#core.Check.context","title":"context  <code>property</code>","text":"<pre><code>context: Context\n</code></pre> <p>Returns the shared context.</p>"},{"location":"dev/publisher/core/#core.Check.errors","title":"errors  <code>property</code>","text":"<pre><code>errors: List[ErrorProcess]\n</code></pre> <p>Returns the list of errors encountered during execution.</p>"},{"location":"dev/publisher/core/#core.Check.status","title":"status  <code>property</code>","text":"<pre><code>status: StatusProcess\n</code></pre> <p>Returns the current status of the process.</p>"},{"location":"dev/publisher/core/#core.Check.add_callback","title":"add_callback","text":"<pre><code>add_callback(callback_type: Callback, callback: callable) -&gt; None\n</code></pre> <p>Adds a callback function to be executed after the process finishes.</p>"},{"location":"dev/publisher/core/#core.Check.add_error","title":"add_error","text":"<pre><code>add_error(error: Optional[str] = 'Unknown error', details: Optional[str] = 'Unknown details', items: Optional[List[str]] = None) -&gt; None\n</code></pre> <p>Adds an error to the list of errors.</p> <p>Parameters:</p>"},{"location":"dev/publisher/core/#core.Check.add_error(error)","title":"<code>error</code>","text":"(<code>str</code>, default:                   <code>'Unknown error'</code> )           \u2013            <p>The error message or name.</p>"},{"location":"dev/publisher/core/#core.Check.add_error(details)","title":"<code>details</code>","text":"(<code>str</code>, default:                   <code>'Unknown details'</code> )           \u2013            <p>Detailed description of the error.</p>"},{"location":"dev/publisher/core/#core.Check.add_error(items)","title":"<code>items</code>","text":"(<code>list</code>, default:                   <code>None</code> )           \u2013            <p>Optional list of items related to the error.</p>"},{"location":"dev/publisher/core/#core.Check.fix_method","title":"fix_method","text":"<pre><code>fix_method() -&gt; None\n</code></pre> <p>Provides a method to fix issues detected by the check.</p>"},{"location":"dev/publisher/core/#core.Check.process","title":"process  <code>abstractmethod</code>","text":"<pre><code>process(context: Context) -&gt; None\n</code></pre> <p>The core logic of the process. This method should be implemented by subclasses with specific logic for the process.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>NotImplementedError</code>             \u2013            <p>If the subclass does not implement this method.</p> </li> </ul>"},{"location":"dev/publisher/core/#core.Check.process(context)","title":"<code>context</code>","text":"(<code>Context</code>)           \u2013            <p>The shared context for accessing and storing data during execution.</p>"},{"location":"dev/publisher/core/#core.Check.set_status","title":"set_status","text":"<pre><code>set_status(status: StatusProcess) -&gt; None\n</code></pre> <p>Sets the status of the process.</p> <p>Parameters:</p>"},{"location":"dev/publisher/core/#core.Check.set_status(status)","title":"<code>status</code>","text":"(<code>StatusProcess</code>)           \u2013            <p>Set status.</p>"},{"location":"dev/publisher/core/#core.Collect","title":"Collect","text":"<pre><code>Collect(manager)\n</code></pre> <p>A class representing the file collection process.</p> <p>This class is responsible for handling the collection of files, storing the collected value, and updating the shared context with the collected data.</p> <p>Attributes:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the collection process.</p> </li> <li> <code>collect_type</code>               (<code>Type</code>)           \u2013            <p>The expected type of the collected data (default is <code>str</code>).</p> </li> <li> <code>_value</code>               (<code>Any</code>)           \u2013            <p>The collected value, initially set to None.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>add_callback</code>             \u2013              <p>Adds a callback function to be executed after the process finishes.</p> </li> <li> <code>add_error</code>             \u2013              <p>Adds an error to the list of errors.</p> </li> <li> <code>process</code>             \u2013              <p>The core logic of the process. This method should be implemented by subclasses with specific logic for the process.</p> </li> <li> <code>set_status</code>             \u2013              <p>Sets the status of the process.</p> </li> </ul>"},{"location":"dev/publisher/core/#core.Collect.callbacks","title":"callbacks  <code>property</code>","text":"<pre><code>callbacks: Dict[Type[Callback], Callable]\n</code></pre> <p>Returns the dict of registered callbacks.</p>"},{"location":"dev/publisher/core/#core.Collect.context","title":"context  <code>property</code>","text":"<pre><code>context: Context\n</code></pre> <p>Returns the shared context.</p>"},{"location":"dev/publisher/core/#core.Collect.errors","title":"errors  <code>property</code>","text":"<pre><code>errors: List[ErrorProcess]\n</code></pre> <p>Returns the list of errors encountered during execution.</p>"},{"location":"dev/publisher/core/#core.Collect.status","title":"status  <code>property</code>","text":"<pre><code>status: StatusProcess\n</code></pre> <p>Returns the current status of the process.</p>"},{"location":"dev/publisher/core/#core.Collect.value","title":"value  <code>property</code> <code>writable</code>","text":"<pre><code>value: Any\n</code></pre> <p>Returns the current collected value.</p>"},{"location":"dev/publisher/core/#core.Collect.add_callback","title":"add_callback","text":"<pre><code>add_callback(callback_type: Callback, callback: callable) -&gt; None\n</code></pre> <p>Adds a callback function to be executed after the process finishes.</p>"},{"location":"dev/publisher/core/#core.Collect.add_error","title":"add_error","text":"<pre><code>add_error(error: Optional[str] = 'Unknown error', details: Optional[str] = 'Unknown details', items: Optional[List[str]] = None) -&gt; None\n</code></pre> <p>Adds an error to the list of errors.</p> <p>Parameters:</p>"},{"location":"dev/publisher/core/#core.Collect.add_error(error)","title":"<code>error</code>","text":"(<code>str</code>, default:                   <code>'Unknown error'</code> )           \u2013            <p>The error message or name.</p>"},{"location":"dev/publisher/core/#core.Collect.add_error(details)","title":"<code>details</code>","text":"(<code>str</code>, default:                   <code>'Unknown details'</code> )           \u2013            <p>Detailed description of the error.</p>"},{"location":"dev/publisher/core/#core.Collect.add_error(items)","title":"<code>items</code>","text":"(<code>list</code>, default:                   <code>None</code> )           \u2013            <p>Optional list of items related to the error.</p>"},{"location":"dev/publisher/core/#core.Collect.process","title":"process  <code>abstractmethod</code>","text":"<pre><code>process(context: Context) -&gt; None\n</code></pre> <p>The core logic of the process. This method should be implemented by subclasses with specific logic for the process.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>NotImplementedError</code>             \u2013            <p>If the subclass does not implement this method.</p> </li> </ul>"},{"location":"dev/publisher/core/#core.Collect.process(context)","title":"<code>context</code>","text":"(<code>Context</code>)           \u2013            <p>The shared context for accessing and storing data during execution.</p>"},{"location":"dev/publisher/core/#core.Collect.set_status","title":"set_status","text":"<pre><code>set_status(status: StatusProcess) -&gt; None\n</code></pre> <p>Sets the status of the process.</p> <p>Parameters:</p>"},{"location":"dev/publisher/core/#core.Collect.set_status(status)","title":"<code>status</code>","text":"(<code>StatusProcess</code>)           \u2013            <p>Set status.</p>"},{"location":"dev/publisher/core/#core.Context","title":"Context","text":"<pre><code>Context()\n</code></pre> <p>A shared context object for storing and accessing data across different processes.</p> <p>Methods:</p> <ul> <li> <code>get_data</code>             \u2013              <p>Retrieves data from the context by key.</p> </li> <li> <code>set_data</code>             \u2013              <p>Stores or updates data in the context.</p> </li> </ul>"},{"location":"dev/publisher/core/#core.Context.get_data","title":"get_data","text":"<pre><code>get_data(key: str) -&gt; Any\n</code></pre> <p>Retrieves data from the context by key.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Any</code> (              <code>Any</code> )          \u2013            <p>The value associated with the key, or None if not found.</p> </li> </ul> Example <p>files = context.get_data('collected_files')</p>"},{"location":"dev/publisher/core/#core.Context.get_data(key)","title":"<code>key</code>","text":"(<code>str</code>)           \u2013            <p>The key or identifier for the data.</p>"},{"location":"dev/publisher/core/#core.Context.set_data","title":"set_data","text":"<pre><code>set_data(key: str, value: Any) -&gt; None\n</code></pre> <p>Stores or updates data in the context.</p> <p>Parameters:</p> Example <p>context.set_data('collected_files', ['file1.txt', 'file2.txt'])</p>"},{"location":"dev/publisher/core/#core.Context.set_data(key)","title":"<code>key</code>","text":"(<code>str</code>)           \u2013            <p>The key or identifier for the data.</p>"},{"location":"dev/publisher/core/#core.Context.set_data(value)","title":"<code>value</code>","text":"(<code>Any</code>)           \u2013            <p>The data to store in the context.</p>"},{"location":"dev/publisher/core/#core.ErrorProcess","title":"ErrorProcess","text":"<pre><code>ErrorProcess(error: Optional[str] = 'Unknown error', details: Optional[str] = 'Unknown details', items: Optional[List[str]] = None)\n</code></pre> <p>Class to represent an error that occurs during process execution.</p> <p>Attributes:</p> <ul> <li> <code>error</code>               (<code>str</code>)           \u2013            <p>A description of the error.</p> </li> <li> <code>details</code>               (<code>str</code>)           \u2013            <p>Additional details about the error.</p> </li> <li> <code>items</code>               (<code>list</code>)           \u2013            <p>Optional list of items or data related to the error.</p> </li> </ul>"},{"location":"dev/publisher/core/#core.ErrorProcess.details","title":"details  <code>property</code>","text":"<pre><code>details: str\n</code></pre> <p>Returns additional details about the error.</p>"},{"location":"dev/publisher/core/#core.ErrorProcess.error","title":"error  <code>property</code>","text":"<pre><code>error: str\n</code></pre> <p>Returns the error description.</p>"},{"location":"dev/publisher/core/#core.ErrorProcess.items","title":"items  <code>property</code>","text":"<pre><code>items: List[str]\n</code></pre> <p>Returns the list of items related to the error.</p>"},{"location":"dev/publisher/core/#core.Extract","title":"Extract","text":"<pre><code>Extract(manager: Manager)\n</code></pre> <p>A class representing the file extraction process.</p> <p>Methods:</p> <ul> <li> <code>add_callback</code>             \u2013              <p>Adds a callback function to be executed after the process finishes.</p> </li> <li> <code>add_error</code>             \u2013              <p>Adds an error to the list of errors.</p> </li> <li> <code>process</code>             \u2013              <p>The core logic of the process. This method should be implemented by subclasses with specific logic for the process.</p> </li> <li> <code>set_status</code>             \u2013              <p>Sets the status of the process.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>callbacks</code>               (<code>Dict[Type[Callback], Callable]</code>)           \u2013            <p>Returns the dict of registered callbacks.</p> </li> <li> <code>context</code>               (<code>Context</code>)           \u2013            <p>Returns the shared context.</p> </li> <li> <code>errors</code>               (<code>List[ErrorProcess]</code>)           \u2013            <p>Returns the list of errors encountered during execution.</p> </li> <li> <code>status</code>               (<code>StatusProcess</code>)           \u2013            <p>Returns the current status of the process.</p> </li> </ul>"},{"location":"dev/publisher/core/#core.Extract.callbacks","title":"callbacks  <code>property</code>","text":"<pre><code>callbacks: Dict[Type[Callback], Callable]\n</code></pre> <p>Returns the dict of registered callbacks.</p>"},{"location":"dev/publisher/core/#core.Extract.context","title":"context  <code>property</code>","text":"<pre><code>context: Context\n</code></pre> <p>Returns the shared context.</p>"},{"location":"dev/publisher/core/#core.Extract.errors","title":"errors  <code>property</code>","text":"<pre><code>errors: List[ErrorProcess]\n</code></pre> <p>Returns the list of errors encountered during execution.</p>"},{"location":"dev/publisher/core/#core.Extract.status","title":"status  <code>property</code>","text":"<pre><code>status: StatusProcess\n</code></pre> <p>Returns the current status of the process.</p>"},{"location":"dev/publisher/core/#core.Extract.add_callback","title":"add_callback","text":"<pre><code>add_callback(callback_type: Callback, callback: callable) -&gt; None\n</code></pre> <p>Adds a callback function to be executed after the process finishes.</p>"},{"location":"dev/publisher/core/#core.Extract.add_error","title":"add_error","text":"<pre><code>add_error(error: Optional[str] = 'Unknown error', details: Optional[str] = 'Unknown details', items: Optional[List[str]] = None) -&gt; None\n</code></pre> <p>Adds an error to the list of errors.</p> <p>Parameters:</p>"},{"location":"dev/publisher/core/#core.Extract.add_error(error)","title":"<code>error</code>","text":"(<code>str</code>, default:                   <code>'Unknown error'</code> )           \u2013            <p>The error message or name.</p>"},{"location":"dev/publisher/core/#core.Extract.add_error(details)","title":"<code>details</code>","text":"(<code>str</code>, default:                   <code>'Unknown details'</code> )           \u2013            <p>Detailed description of the error.</p>"},{"location":"dev/publisher/core/#core.Extract.add_error(items)","title":"<code>items</code>","text":"(<code>list</code>, default:                   <code>None</code> )           \u2013            <p>Optional list of items related to the error.</p>"},{"location":"dev/publisher/core/#core.Extract.process","title":"process  <code>abstractmethod</code>","text":"<pre><code>process(context: Context) -&gt; None\n</code></pre> <p>The core logic of the process. This method should be implemented by subclasses with specific logic for the process.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>NotImplementedError</code>             \u2013            <p>If the subclass does not implement this method.</p> </li> </ul>"},{"location":"dev/publisher/core/#core.Extract.process(context)","title":"<code>context</code>","text":"(<code>Context</code>)           \u2013            <p>The shared context for accessing and storing data during execution.</p>"},{"location":"dev/publisher/core/#core.Extract.set_status","title":"set_status","text":"<pre><code>set_status(status: StatusProcess) -&gt; None\n</code></pre> <p>Sets the status of the process.</p> <p>Parameters:</p>"},{"location":"dev/publisher/core/#core.Extract.set_status(status)","title":"<code>status</code>","text":"(<code>StatusProcess</code>)           \u2013            <p>Set status.</p>"},{"location":"dev/publisher/core/#core.Manager","title":"Manager","text":"<pre><code>Manager()\n</code></pre> <p>Manager class that manages the registration and execution of different processes, including collecting, checking, extraction, and pushing to the database.</p> <p>Attributes:</p> <ul> <li> <code>context</code>               (<code>Context</code>)           \u2013            <p>The shared context for managing data                among the different processes.</p> </li> <li> <code>collectors</code>               (<code>List[Collect]</code>)           \u2013            <p>A list of collecting processes.</p> </li> <li> <code>checks</code>               (<code>List[Check]</code>)           \u2013            <p>A list of checking processes.</p> </li> <li> <code>extractors</code>               (<code>List[Extract]</code>)           \u2013            <p>A list of extraction processes.</p> </li> <li> <code>pushes</code>               (<code>List[Push]</code>)           \u2013            <p>A list of push processes for database operations.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>processes</code>             \u2013              <p>Returns a dictionary with all the registered processes.</p> </li> <li> <code>publish</code>             \u2013              <p>Executes the registered processes in sequence.</p> </li> <li> <code>register</code>             \u2013              <p>Registers a process in the correct category based on its type.</p> </li> </ul>"},{"location":"dev/publisher/core/#core.Manager.context","title":"context  <code>property</code>","text":"<pre><code>context\n</code></pre> <p>Gets the shared context for the Manager.</p>"},{"location":"dev/publisher/core/#core.Manager.processes","title":"processes","text":"<pre><code>processes() -&gt; Dict[str, List[Process]]\n</code></pre> <p>Returns a dictionary with all the registered processes.</p> <p>Returns:</p> <ul> <li> <code>dict</code> (              <code>Dict[str, List[Process]]</code> )          \u2013            <p>A dictionary with process types as keys and lists of instances as values.</p> </li> </ul>"},{"location":"dev/publisher/core/#core.Manager.publish","title":"publish","text":"<pre><code>publish() -&gt; None\n</code></pre> <p>Executes the registered processes in sequence.</p>"},{"location":"dev/publisher/core/#core.Manager.register","title":"register","text":"<pre><code>register(process: Process) -&gt; None\n</code></pre> <p>Registers a process in the correct category based on its type.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the process type is unknown.</p> </li> </ul>"},{"location":"dev/publisher/core/#core.Manager.register(process)","title":"<code>process</code>","text":"(<code>Process</code>)           \u2013            <p>An process of a subclass of Process to be registered.</p>"},{"location":"dev/publisher/core/#core.Process","title":"Process","text":"<pre><code>Process(manager: Manager)\n</code></pre> <pre><code>Abstract base class for all processes in the task publishing pipeline.\n\nAttributes:\n    name (str): The name of the process.\n    compulsory (bool): Indicates if the process is mandatory.\n    status (bool): The status of the process (True for success, False for failure, None for not yet executed).\n    info (str): Information or description of the process.\n    errors (list): A list of ErrorProcess objects representing errors encountered during execution.\n    context (Context): A reference to the shared Context object for data exchange.\n    callbacks (dict): A dict of callback functions to be executed when a specified action occurs.\n</code></pre> <p>.</p> <p>Methods:</p> <ul> <li> <code>add_callback</code>             \u2013              <p>Adds a callback function to be executed after the process finishes.</p> </li> <li> <code>add_error</code>             \u2013              <p>Adds an error to the list of errors.</p> </li> <li> <code>process</code>             \u2013              <p>The core logic of the process. This method should be implemented by subclasses with specific logic for the process.</p> </li> <li> <code>set_status</code>             \u2013              <p>Sets the status of the process.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>callbacks</code>               (<code>Dict[Type[Callback], Callable]</code>)           \u2013            <p>Returns the dict of registered callbacks.</p> </li> <li> <code>context</code>               (<code>Context</code>)           \u2013            <p>Returns the shared context.</p> </li> <li> <code>errors</code>               (<code>List[ErrorProcess]</code>)           \u2013            <p>Returns the list of errors encountered during execution.</p> </li> <li> <code>status</code>               (<code>StatusProcess</code>)           \u2013            <p>Returns the current status of the process.</p> </li> </ul>"},{"location":"dev/publisher/core/#core.Process.callbacks","title":"callbacks  <code>property</code>","text":"<pre><code>callbacks: Dict[Type[Callback], Callable]\n</code></pre> <p>Returns the dict of registered callbacks.</p>"},{"location":"dev/publisher/core/#core.Process.context","title":"context  <code>property</code>","text":"<pre><code>context: Context\n</code></pre> <p>Returns the shared context.</p>"},{"location":"dev/publisher/core/#core.Process.errors","title":"errors  <code>property</code>","text":"<pre><code>errors: List[ErrorProcess]\n</code></pre> <p>Returns the list of errors encountered during execution.</p>"},{"location":"dev/publisher/core/#core.Process.status","title":"status  <code>property</code>","text":"<pre><code>status: StatusProcess\n</code></pre> <p>Returns the current status of the process.</p>"},{"location":"dev/publisher/core/#core.Process.add_callback","title":"add_callback","text":"<pre><code>add_callback(callback_type: Callback, callback: callable) -&gt; None\n</code></pre> <p>Adds a callback function to be executed after the process finishes.</p>"},{"location":"dev/publisher/core/#core.Process.add_error","title":"add_error","text":"<pre><code>add_error(error: Optional[str] = 'Unknown error', details: Optional[str] = 'Unknown details', items: Optional[List[str]] = None) -&gt; None\n</code></pre> <p>Adds an error to the list of errors.</p> <p>Parameters:</p>"},{"location":"dev/publisher/core/#core.Process.add_error(error)","title":"<code>error</code>","text":"(<code>str</code>, default:                   <code>'Unknown error'</code> )           \u2013            <p>The error message or name.</p>"},{"location":"dev/publisher/core/#core.Process.add_error(details)","title":"<code>details</code>","text":"(<code>str</code>, default:                   <code>'Unknown details'</code> )           \u2013            <p>Detailed description of the error.</p>"},{"location":"dev/publisher/core/#core.Process.add_error(items)","title":"<code>items</code>","text":"(<code>list</code>, default:                   <code>None</code> )           \u2013            <p>Optional list of items related to the error.</p>"},{"location":"dev/publisher/core/#core.Process.process","title":"process  <code>abstractmethod</code>","text":"<pre><code>process(context: Context) -&gt; None\n</code></pre> <p>The core logic of the process. This method should be implemented by subclasses with specific logic for the process.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>NotImplementedError</code>             \u2013            <p>If the subclass does not implement this method.</p> </li> </ul>"},{"location":"dev/publisher/core/#core.Process.process(context)","title":"<code>context</code>","text":"(<code>Context</code>)           \u2013            <p>The shared context for accessing and storing data during execution.</p>"},{"location":"dev/publisher/core/#core.Process.set_status","title":"set_status","text":"<pre><code>set_status(status: StatusProcess) -&gt; None\n</code></pre> <p>Sets the status of the process.</p> <p>Parameters:</p>"},{"location":"dev/publisher/core/#core.Process.set_status(status)","title":"<code>status</code>","text":"(<code>StatusProcess</code>)           \u2013            <p>Set status.</p>"},{"location":"dev/publisher/core/#core.Push","title":"Push","text":"<pre><code>Push(manager: Manager)\n</code></pre> <p>A class representing the process to push data to the database.</p> <p>Methods:</p> <ul> <li> <code>add_callback</code>             \u2013              <p>Adds a callback function to be executed after the process finishes.</p> </li> <li> <code>add_error</code>             \u2013              <p>Adds an error to the list of errors.</p> </li> <li> <code>process</code>             \u2013              <p>The core logic of the process. This method should be implemented by subclasses with specific logic for the process.</p> </li> <li> <code>set_status</code>             \u2013              <p>Sets the status of the process.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>callbacks</code>               (<code>Dict[Type[Callback], Callable]</code>)           \u2013            <p>Returns the dict of registered callbacks.</p> </li> <li> <code>context</code>               (<code>Context</code>)           \u2013            <p>Returns the shared context.</p> </li> <li> <code>errors</code>               (<code>List[ErrorProcess]</code>)           \u2013            <p>Returns the list of errors encountered during execution.</p> </li> <li> <code>status</code>               (<code>StatusProcess</code>)           \u2013            <p>Returns the current status of the process.</p> </li> </ul>"},{"location":"dev/publisher/core/#core.Push.callbacks","title":"callbacks  <code>property</code>","text":"<pre><code>callbacks: Dict[Type[Callback], Callable]\n</code></pre> <p>Returns the dict of registered callbacks.</p>"},{"location":"dev/publisher/core/#core.Push.context","title":"context  <code>property</code>","text":"<pre><code>context: Context\n</code></pre> <p>Returns the shared context.</p>"},{"location":"dev/publisher/core/#core.Push.errors","title":"errors  <code>property</code>","text":"<pre><code>errors: List[ErrorProcess]\n</code></pre> <p>Returns the list of errors encountered during execution.</p>"},{"location":"dev/publisher/core/#core.Push.status","title":"status  <code>property</code>","text":"<pre><code>status: StatusProcess\n</code></pre> <p>Returns the current status of the process.</p>"},{"location":"dev/publisher/core/#core.Push.add_callback","title":"add_callback","text":"<pre><code>add_callback(callback_type: Callback, callback: callable) -&gt; None\n</code></pre> <p>Adds a callback function to be executed after the process finishes.</p>"},{"location":"dev/publisher/core/#core.Push.add_error","title":"add_error","text":"<pre><code>add_error(error: Optional[str] = 'Unknown error', details: Optional[str] = 'Unknown details', items: Optional[List[str]] = None) -&gt; None\n</code></pre> <p>Adds an error to the list of errors.</p> <p>Parameters:</p>"},{"location":"dev/publisher/core/#core.Push.add_error(error)","title":"<code>error</code>","text":"(<code>str</code>, default:                   <code>'Unknown error'</code> )           \u2013            <p>The error message or name.</p>"},{"location":"dev/publisher/core/#core.Push.add_error(details)","title":"<code>details</code>","text":"(<code>str</code>, default:                   <code>'Unknown details'</code> )           \u2013            <p>Detailed description of the error.</p>"},{"location":"dev/publisher/core/#core.Push.add_error(items)","title":"<code>items</code>","text":"(<code>list</code>, default:                   <code>None</code> )           \u2013            <p>Optional list of items related to the error.</p>"},{"location":"dev/publisher/core/#core.Push.process","title":"process  <code>abstractmethod</code>","text":"<pre><code>process(context: Context) -&gt; None\n</code></pre> <p>The core logic of the process. This method should be implemented by subclasses with specific logic for the process.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>NotImplementedError</code>             \u2013            <p>If the subclass does not implement this method.</p> </li> </ul>"},{"location":"dev/publisher/core/#core.Push.process(context)","title":"<code>context</code>","text":"(<code>Context</code>)           \u2013            <p>The shared context for accessing and storing data during execution.</p>"},{"location":"dev/publisher/core/#core.Push.set_status","title":"set_status","text":"<pre><code>set_status(status: StatusProcess) -&gt; None\n</code></pre> <p>Sets the status of the process.</p> <p>Parameters:</p>"},{"location":"dev/publisher/core/#core.Push.set_status(status)","title":"<code>status</code>","text":"(<code>StatusProcess</code>)           \u2013            <p>Set status.</p>"},{"location":"dev/publisher/core/#core.StatusProcess","title":"StatusProcess","text":"<p>Enum-like class representing the status of a process.</p>"},{"location":"dev/publisher/core/#core.log_execution","title":"log_execution","text":"<pre><code>log_execution(func)\n</code></pre> <p>Decorator to log the execution of process methods.</p>"},{"location":"dev/publisher/examples/","title":"Examples","text":""},{"location":"dev/publisher/examples/#introduction-to-publisher-framework","title":"Introduction to Publisher Framework","text":"<p>This guide introduces you to a practical use of the Task Publishing Framework, illustrating how to create a simple publishing pipeline with custom collection, checking, extraction, and data push processes.</p> <p>We will walk through defining specific tasks, checks, extraction, and push steps, and finally create an interface to execute the process.</p>"},{"location":"dev/publisher/examples/#code-overview","title":"Code Overview","text":"<p>Our example includes the following components:</p> <ul> <li>Collection Tasks: <code>CollectTask</code>, <code>CollectPreview</code>, <code>CollectFile</code>, <code>CollectBID</code>, and <code>CollectDescription</code>.</li> <li>Validation Checks: <code>CheckRepeatedNameNodes</code>, <code>CheckPastedNodes</code>, and <code>CheckUnknownNodes</code>.</li> <li>Extraction: <code>ExtractModel</code>.</li> <li>Push: <code>PushSGModel</code>.</li> </ul> <p>These processes are registered with the <code>Manager</code> and executed in sequence.</p>"},{"location":"dev/publisher/examples/#requirements","title":"Requirements","text":"<p>Ensure that <code>PySide6</code> or <code>PySide2</code> and any other necessary dependencies are installed:</p> <p></p><pre><code>pip install PySide6\n</code></pre> or <pre><code>pip install PySide2\n</code></pre> <p>Prerequisites Before you begin, ensure you have Python, PySide2 or PySide6, and a compatible environment to run this application. Familiarity with Maya's Python API will be helpful if you plan to implement checks for Maya nodes.</p> <p>Setup Imports and Logging</p> <p>First, set up the necessary imports and configure a basic logger:</p> <pre><code>from pathlib import Path\nimport logging\n\ntry:\n    from PySide6.QtWidgets import QApplication\nexcept:\n    from PySide2.QtWidgets import QApplication\n\nfrom publisher.core import Collect, Check, Extract, Push, Manager\nfrom publisher.ui.widget import ManagerWidget\n\nlogging.basicConfig(level=logging.DEBUG)\nlogger = logging.getLogger(__name__)\n</code></pre> <p>Explanation: This block imports required modules and configures a logger for debugging. Creating Collect Classes</p> <p>Define classes to collect different types of data. Each Collect class represents a piece of data you want to gather in your workflow. Here\u2019s a breakdown of the collect classes:</p> <p>Python </p><pre><code>class CollectTask(Collect):\n    name = \"task_id\"\n    collect_type = int\n\n    def process(self, context):\n        self.value = 512\n\nclass CollectPreview(Collect):\n    name = \"preview\"\n    collect_type = Path\n\n    def process(self, context):\n        self.value = Path(\"/test_folder/preview.jpg\")\n</code></pre> <p>Explanation: CollectTask collects an integer ID for the task. CollectPreview collects the path to a preview image. Both classes override process to set the value attribute. Creating Check Classes</p> <p>Checks validate data collected in the previous step. In this example, we create checks for repeated node names, pasted nodes, and unknown nodes in Maya.</p> <pre><code>class CheckRepeatedNameNodes(Check):\n    name = \"Check repeated node names\"\n    info = \"Checks whether there are 2 or more nodes sharing the same short name.\"\n\n    def process(self, context):\n        import maya.cmds as cmds\n\n        status = True\n        errors = []\n\n        # Retrieve all node names and check for duplicates\n        all_dag_list_long = cmds.ls(type=\"transform\", l=True)\n        all_dag_list_short = [item.split(\"|\")[-1] for item in all_dag_list_long]\n        all_dag_set = set(all_dag_list_short)\n\n        # Collect duplicates\n        if len(all_dag_list_short) != len(all_dag_set):\n            repeated_nodes = [node for node in all_dag_list_long if all_dag_list_short.count(node.split(\"|\")[-1]) &gt; 1]\n            errors = [{\"text\": \"Repeated node names\", \"list\": [[node, node] for node in repeated_nodes]}]\n            status = False\n\n        return status, errors\n</code></pre> <p>Explanation: This CheckRepeatedNameNodes class examines Maya nodes for duplicated names. If duplicates are found, errors are reported, and status is set to False. Creating Extract and Push Classes</p> <p>Extraction and pushing represent the final stages of the process, where data is saved and uploaded, respectively.</p> <pre><code>class ExtractModel(Extract):\n    name = \"Extract USD\"\n\n    def process(self, context):\n        file = context.get_data(\"file\")\n        logger.debug(f\"THIS IS FILE: {file}\")\n\nclass PushSGModel(Push):\n    name = \"Push Version\"\n\n    def process(self, context): ...\n</code></pre> <p>Explanation: ExtractModel logs the file being processed, while PushSGModel is designed to push a new version. Creating and Running the Manager</p> <p>Register the processes with the Manager and launch the application interface using ManagerWidget:</p> <pre><code>def main() -&gt; None:\n    app = QApplication()\n    manager = Manager()\n\n    # Register all custom processes\n    manager.register(CollectTask)\n    manager.register(CollectFile)\n    manager.register(CollectPreview)\n    manager.register(CollectBID)\n    manager.register(CollectDescription)\n    manager.register(CheckRepeatedNameNodes)\n    manager.register(CheckPastedNodes)\n    manager.register(CheckUnknownNodes)\n    manager.register(ExtractModel)\n    manager.register(PushSGModel)\n\n    # Create and show the UI\n    interface = ManagerWidget(manager)\n    interface.show()\n\n    try:\n        app.exec()\n    except:\n        app.exec_()\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>Explanation: The main() function sets up the application environment. Each custom process is registered with the manager. The UI is displayed via ManagerWidget, showing all registered processes. Running the Application To run the application, execute the script in your terminal:</p> <p>Bash</p> <p>python your_script_name.py You will see a user interface displaying each registered process. Through this interface, you can run each process sequentially, view results, and handle errors.</p> <p>Conclusion This example demonstrates how to set up a simple workflow for collecting data, validating it, and saving or pushing it. The modular structure allows you to easily expand functionality by adding new Collect, Check, Extract, or Push classes, making the framework adaptable to various use cases.</p>"},{"location":"dev/publisher/modules/","title":"Modules","text":""},{"location":"dev/publisher/modules/#indice-de-modulos","title":"\u00cdndice de M\u00f3dulos","text":"<p>Este archivo se genera autom\u00e1ticamente. No editar.</p>"},{"location":"dev/publisher/modules/#modulos","title":"M\u00f3dulos","text":"<ul> <li>core</li> <li>examples.example</li> <li>ui.check_page</li> <li>ui.collect_page</li> <li>ui.extract_page</li> <li>ui.push_page</li> <li>ui.qt_widgets</li> <li>utils.maya_checks</li> <li>widget</li> </ul>"},{"location":"dev/publisher/readme/","title":"Introducci\u00f3n","text":""},{"location":"dev/publisher/readme/#task-publishing-framework","title":"Task Publishing Framework","text":"<p>This Python task publishing framework is designed to streamline the execution of sequential processes such as file collection, validation, extraction, and database updating. The framework allows developers to register and execute custom processes within a flexible structure, using a shared context for data exchange.</p>"},{"location":"dev/publisher/readme/#features","title":"Features","text":"<ul> <li>Modular: Define and register different types of processes     ([Collect]{.title-ref}, [Check]{.title-ref}, [Extract]{.title-ref},     [Push]{.title-ref}).</li> <li>Shared Context: Use a [Context]{.title-ref} object to share data     between processes.</li> <li>Error Handling: Efficiently track and manage errors through the     [ErrorProcess]{.title-ref} class.</li> <li>Callbacks: Execute callback functions after processes finish.</li> <li>Easy Integration: Extensible and flexible, allowing for the     creation of custom processes.</li> </ul>"},{"location":"dev/publisher/readme/#installation","title":"Installation","text":"<p>First, clone the repository and navigate to the project folder:</p> <pre><code>git clone https://github.com/mondotv/publisher.git\ncd task-publishing-framework\n</code></pre> <p>Ensure you have a virtual environment set up, and install dependencies if required:</p> <pre><code>pip install -r requirements.txt\n</code></pre>"},{"location":"dev/publisher/readme/#basic-usage","title":"Basic Usage","text":"<ol> <li> <p>Create a custom process class</p> <p>To define a new process, subclass one of the abstract process types ([Collect]{.title-ref}, [Check]{.title-ref}, [Extract]{.title-ref}, [Push]{.title-ref}) and implement the [process]{.title-ref} method. Here\\'s an example of a custom collection process:</p> <pre><code>from publisher.core import Collect\n\nclass CustomCollect(Collect):\n   name = \"Collect Files\"\n   collect_type = list  # Expected data type\n\n   def process(self, context):\n      # Implement collection logic\n      files = [\"file1.txt\", \"file2.txt\"]\n      self.value = files\n</code></pre> </li> <li> <p>Register and execute processes</p> <p>After defining the process, register it with the [Manager]{.title-ref} and run the publishing sequence:</p> <pre><code>from publisher.core import Manager\n\n# Create an instance of manager\nmanager = Manager()\n\n# Register the processes\nmanager.register(CustomCollect)\n\n# Execute the processes\nmanager.publish()\n\n# Retrieve results from the shared context\ncollected_files = manager.context.get_data(\"Collect Files\")\nprint(collected_files)  # Output: ['file1.txt', 'file2.txt']\n</code></pre> </li> <li> <p>Error management and status</p> <p>The framework captures and manages errors automatically. You can add errors to any process, and the [Process]{.title-ref} class will log them:</p> <pre><code>from publisher.core import Process, Context\n\nclass MyCheck(Process):\n   name = \"Custom Check\"\n\n   def process(self, context):\n      # Simulate a failure\n      if not context.get_data(\"required_data\"):\n         self.add_error(\"Missing data\", \"The required_data key is missing in context.\")\n         self.set_status(False)\n\n# Register and execute\ncheck = MyCheck(manager)\nmanager.register(check)\nmanager.publish()\n</code></pre> </li> <li> <p>Callbacks</p> <p>You can add callbacks to any process, which will execute once the process finishes:</p> <pre><code>def notify_user(process):\n   print(f\"Process {process.name} has finished!\")\n\ncheck.add_callback(notify_user)\n</code></pre> </li> </ol>"},{"location":"dev/publisher/readme/#project-structure","title":"Project Structure","text":"<ul> <li>`core.py`: Contains the base classes for processes     ([Process]{.title-ref}, [Collect]{.title-ref}, [Check]{.title-ref},     [Extract]{.title-ref}, [Push]{.title-ref}) and the     [Manager]{.title-ref} class.</li> <li>`tests/`: Includes tests to validate the framework\\'s     functionality.</li> <li>`examples/`: Includes practical examples of how to make a simple     publisher with the framework.</li> <li>`docs/`: Project documentation, generated using Sphinx.</li> </ul>"},{"location":"dev/publisher/readme/#extensibility","title":"Extensibility","text":"<p>This framework is easily extensible. You can create new types of processes by subclassing the base [Process]{.title-ref} class and tailoring them to your application needs. Here\\'s an example of an extraction process:</p> <pre><code>from publisher.core import Extract\n\nclass CustomExtract(Extract):\n   name = \"Extract Data\"\n\n   def process(self, context):\n      # Extraction logic\n      data = context.get_data(\"collected_files\")\n      extracted_data = [file.upper() for file in data]  # Example transformation\n      self.context.set_data(\"extracted_data\", extracted_data)\n</code></pre>"},{"location":"dev/publisher/readme/#documentation","title":"Documentation","text":"<p>For more details on the classes and methods, refer to the project documentation located in the [docs/]{.title-ref} directory. The documentation includes:</p> <ul> <li>Detailed guides</li> <li>Usage examples</li> <li>Descriptions of each class and function</li> </ul>"},{"location":"dev/publisher/readme/#modules","title":"Modules","text":"<ul> <li>\u00cdndice de m\u00f3dulos</li> <li>Ejemplos</li> </ul>"},{"location":"dev/publisher/widget/","title":"widget","text":""},{"location":"dev/publisher/widget/#widget_1","title":"<code>widget</code>","text":""},{"location":"dev/publisher/widget/#widget","title":"widget","text":"<p>Classes:</p> <ul> <li> <code>ManagerWidget</code>           \u2013            <p>Main window for the task publisher management interface, displaying various task-related tabs.</p> </li> </ul>"},{"location":"dev/publisher/widget/#widget.ManagerWidget","title":"ManagerWidget","text":"<pre><code>ManagerWidget(manager: Manager)\n</code></pre> <p>Main window for the task publisher management interface, displaying various task-related tabs.</p> <p>This widget initializes as the main application window and dynamically generates pages based on the types of processes registered within a <code>Manager</code> instance.</p> <p>Parameters:</p> <p>Methods:</p> <ul> <li> <code>create_pages</code>             \u2013              <p>Dynamically create pages in the main window for each type of process in the Manager.</p> </li> <li> <code>publish</code>             \u2013              <p>Trigger the publishing process by calling the manager's publish method.</p> </li> <li> <code>set_tab_page_status</code>             \u2013              <p>Update the color of the status button in the button bar based on the process status.</p> </li> </ul>"},{"location":"dev/publisher/widget/#widget.ManagerWidget(manager)","title":"<code>manager</code>","text":"(<code>Manager</code>)           \u2013            <p>An instance of the Manager class, containing the registered processes.</p>"},{"location":"dev/publisher/widget/#widget.ManagerWidget.create_pages","title":"create_pages","text":"<pre><code>create_pages(processes: Dict[Type[Process], List[Process]]) -&gt; None\n</code></pre> <p>Dynamically create pages in the main window for each type of process in the Manager.</p> <p>This method iterates over the provided dictionary of processes and creates a specific page for each recognized process type (Collect, Check, Extract, Push). It also creates a button in the button bar to switch to each page.</p> <p>Parameters:</p>"},{"location":"dev/publisher/widget/#widget.ManagerWidget.create_pages(processes)","title":"<code>processes</code>","text":"(<code>Dict[Type[Process], List[Process]]</code>)           \u2013            <p>A dictionary where each key is a process type (such as Collect, Check, etc.) and the corresponding value is a list of process instances of that type.</p>"},{"location":"dev/publisher/widget/#widget.ManagerWidget.publish","title":"publish","text":"<pre><code>publish() -&gt; None\n</code></pre> <p>Trigger the publishing process by calling the manager's publish method.</p> <p>This method runs in a separate thread to prevent blocking the UI. After publishing, it updates the status of each page based on the results.</p>"},{"location":"dev/publisher/widget/#widget.ManagerWidget.set_tab_page_status","title":"set_tab_page_status","text":"<pre><code>set_tab_page_status(page: ProcessorPage, status: StatusProcess) -&gt; None\n</code></pre> <p>Update the color of the status button in the button bar based on the process status.</p> <p>Parameters:</p>"},{"location":"dev/publisher/widget/#widget.ManagerWidget.set_tab_page_status(page)","title":"<code>page</code>","text":"(<code>ProcessorPage</code>)           \u2013            <p>The page whose status button color will be updated.</p>"},{"location":"dev/publisher/widget/#widget.ManagerWidget.set_tab_page_status(status)","title":"<code>status</code>","text":"(<code>StatusProcess</code>)           \u2013            <p>The current status of the process, which determines the button color.</p>"},{"location":"dev/publisher/examples/example/","title":"example","text":""},{"location":"dev/publisher/examples/example/#example","title":"<code>example</code>","text":""},{"location":"dev/publisher/examples/example/#examples.example","title":"example","text":"<p>Functions:</p> <ul> <li> <code>main</code>             \u2013              <p>Main entry point for the application.</p> </li> </ul>"},{"location":"dev/publisher/examples/example/#examples.example.main","title":"main","text":"<pre><code>main() -&gt; None\n</code></pre> <p>Main entry point for the application.</p>"},{"location":"dev/publisher/ui/check_page/","title":"check_page","text":""},{"location":"dev/publisher/ui/check_page/#check_page","title":"<code>check_page</code>","text":""},{"location":"dev/publisher/ui/check_page/#ui.check_page","title":"check_page","text":""},{"location":"dev/publisher/ui/collect_page/","title":"collect_page","text":""},{"location":"dev/publisher/ui/collect_page/#collect_page","title":"<code>collect_page</code>","text":""},{"location":"dev/publisher/ui/collect_page/#ui.collect_page","title":"collect_page","text":"<p>Classes:</p> <ul> <li> <code>CollectPage</code>           \u2013            <p>This class generates a CollectPage dynamically based on the instances</p> </li> <li> <code>CollectWidget</code>           \u2013            </li> </ul>"},{"location":"dev/publisher/ui/collect_page/#ui.collect_page.CollectPage","title":"CollectPage","text":"<pre><code>CollectPage(list_process: List[Process], parent: QWidget = None)\n</code></pre> <p>This class generates a CollectPage dynamically based on the instances of Collect processes registered in the manager publisher.</p> <p>Methods:</p> <ul> <li> <code>start_collection</code>             \u2013              <p>Start the collection process by calling the execute method of each instance.</p> </li> </ul>"},{"location":"dev/publisher/ui/collect_page/#ui.collect_page.CollectPage.start_collection","title":"start_collection","text":"<pre><code>start_collection() -&gt; None\n</code></pre> <p>Start the collection process by calling the execute method of each instance. Determines whether the collect requires manual input.</p>"},{"location":"dev/publisher/ui/collect_page/#ui.collect_page.CollectWidget","title":"CollectWidget","text":"<p>Methods:</p> <ul> <li> <code>create_collector_input</code>             \u2013              <p>Add an input field based on the collect_type of each instance.</p> </li> </ul>"},{"location":"dev/publisher/ui/collect_page/#ui.collect_page.CollectWidget.create_collector_input","title":"create_collector_input","text":"<pre><code>create_collector_input(collect) -&gt; None\n</code></pre> <p>Add an input field based on the collect_type of each instance.</p> <p>Parameters:</p>"},{"location":"dev/publisher/ui/collect_page/#ui.collect_page.CollectWidget.create_collector_input(collect)","title":"<code>collect</code>","text":"(<code>Collect</code>)           \u2013            <p>The collect instance.</p>"},{"location":"dev/publisher/ui/extract_page/","title":"extract_page","text":""},{"location":"dev/publisher/ui/extract_page/#extract_page","title":"<code>extract_page</code>","text":""},{"location":"dev/publisher/ui/extract_page/#ui.extract_page","title":"extract_page","text":""},{"location":"dev/publisher/ui/push_page/","title":"push_page","text":""},{"location":"dev/publisher/ui/push_page/#push_page","title":"<code>push_page</code>","text":""},{"location":"dev/publisher/ui/push_page/#ui.push_page","title":"push_page","text":""},{"location":"dev/publisher/ui/qt_widgets/","title":"qt_widgets","text":""},{"location":"dev/publisher/ui/qt_widgets/#qt_widgets","title":"<code>qt_widgets</code>","text":""},{"location":"dev/publisher/ui/qt_widgets/#ui.qt_widgets","title":"qt_widgets","text":"<p>Classes:</p> <ul> <li> <code>Dropdown</code>           \u2013            <p>Utility class used all throught the UI as a hide and show button.</p> </li> <li> <code>ErrorListWidget</code>           \u2013            <p>Used mostly to display a list of the errors that were found in the errors.</p> </li> </ul>"},{"location":"dev/publisher/ui/qt_widgets/#ui.qt_widgets.Dropdown","title":"Dropdown","text":"<pre><code>Dropdown(title='', parent=None)\n</code></pre> <p>Utility class used all throught the UI as a hide and show button.</p>"},{"location":"dev/publisher/ui/qt_widgets/#ui.qt_widgets.ErrorListWidget","title":"ErrorListWidget","text":"<pre><code>ErrorListWidget(parent=None)\n</code></pre> <p>Used mostly to display a list of the errors that were found in the errors.</p>"},{"location":"dev/publisher/utils/maya_checks/","title":"maya_checks","text":""},{"location":"dev/publisher/utils/maya_checks/#maya_checks","title":"<code>maya_checks</code>","text":""},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks","title":"maya_checks","text":"<p>Classes:</p> <ul> <li> <code>CheckImagePlanes</code>           \u2013            </li> <li> <code>CheckLights</code>           \u2013            </li> <li> <code>CheckNodeHistory</code>           \u2013            </li> <li> <code>CheckOutlinerAssets</code>           \u2013            </li> <li> <code>CheckResidualAovs</code>           \u2013            </li> <li> <code>CheckSequenceManager</code>           \u2013            </li> <li> <code>CheckStarLike</code>           \u2013            <p>Starlike polygons are a type of nGons, where the angles</p> </li> </ul>"},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks.CheckImagePlanes","title":"CheckImagePlanes","text":"<pre><code>CheckImagePlanes(manager: Manager)\n</code></pre> <p>Methods:</p> <ul> <li> <code>add_callback</code>             \u2013              <p>Adds a callback function to be executed after the process finishes.</p> </li> <li> <code>add_error</code>             \u2013              <p>Adds an error to the list of errors.</p> </li> <li> <code>process</code>             \u2013              <p>Checks whether all the dependencies has the environemnt variable in them.</p> </li> <li> <code>set_status</code>             \u2013              <p>Sets the status of the process.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>callbacks</code>               (<code>Dict[Type[Callback], Callable]</code>)           \u2013            <p>Returns the dict of registered callbacks.</p> </li> <li> <code>context</code>               (<code>Context</code>)           \u2013            <p>Returns the shared context.</p> </li> <li> <code>errors</code>               (<code>List[ErrorProcess]</code>)           \u2013            <p>Returns the list of errors encountered during execution.</p> </li> <li> <code>status</code>               (<code>StatusProcess</code>)           \u2013            <p>Returns the current status of the process.</p> </li> </ul>"},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks.CheckImagePlanes.callbacks","title":"callbacks  <code>property</code>","text":"<pre><code>callbacks: Dict[Type[Callback], Callable]\n</code></pre> <p>Returns the dict of registered callbacks.</p>"},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks.CheckImagePlanes.context","title":"context  <code>property</code>","text":"<pre><code>context: Context\n</code></pre> <p>Returns the shared context.</p>"},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks.CheckImagePlanes.errors","title":"errors  <code>property</code>","text":"<pre><code>errors: List[ErrorProcess]\n</code></pre> <p>Returns the list of errors encountered during execution.</p>"},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks.CheckImagePlanes.status","title":"status  <code>property</code>","text":"<pre><code>status: StatusProcess\n</code></pre> <p>Returns the current status of the process.</p>"},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks.CheckImagePlanes.add_callback","title":"add_callback","text":"<pre><code>add_callback(callback_type: Callback, callback: callable) -&gt; None\n</code></pre> <p>Adds a callback function to be executed after the process finishes.</p>"},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks.CheckImagePlanes.add_error","title":"add_error","text":"<pre><code>add_error(error: Optional[str] = 'Unknown error', details: Optional[str] = 'Unknown details', items: Optional[List[str]] = None) -&gt; None\n</code></pre> <p>Adds an error to the list of errors.</p> <p>Parameters:</p>"},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks.CheckImagePlanes.add_error(error)","title":"<code>error</code>","text":"(<code>str</code>, default:                   <code>'Unknown error'</code> )           \u2013            <p>The error message or name.</p>"},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks.CheckImagePlanes.add_error(details)","title":"<code>details</code>","text":"(<code>str</code>, default:                   <code>'Unknown details'</code> )           \u2013            <p>Detailed description of the error.</p>"},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks.CheckImagePlanes.add_error(items)","title":"<code>items</code>","text":"(<code>list</code>, default:                   <code>None</code> )           \u2013            <p>Optional list of items related to the error.</p>"},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks.CheckImagePlanes.process","title":"process","text":"<pre><code>process(context: Context) -&gt; None\n</code></pre> <p>Checks whether all the dependencies has the environemnt variable in them.</p> <p>status : Bool errors : List errors = {\"text\":Informacion del error,\"list\":error_objects} error_objects : Error list objects = [node error, object] return : {\"status\":status,\"errors\":errors}</p>"},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks.CheckImagePlanes.set_status","title":"set_status","text":"<pre><code>set_status(status: StatusProcess) -&gt; None\n</code></pre> <p>Sets the status of the process.</p> <p>Parameters:</p>"},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks.CheckImagePlanes.set_status(status)","title":"<code>status</code>","text":"(<code>StatusProcess</code>)           \u2013            <p>Set status.</p>"},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks.CheckLights","title":"CheckLights","text":"<pre><code>CheckLights(manager: Manager)\n</code></pre> <p>Methods:</p> <ul> <li> <code>add_callback</code>             \u2013              <p>Adds a callback function to be executed after the process finishes.</p> </li> <li> <code>add_error</code>             \u2013              <p>Adds an error to the list of errors.</p> </li> <li> <code>process</code>             \u2013              <p>Checks whether all the dependencies has the environemnt variable in them.</p> </li> <li> <code>set_status</code>             \u2013              <p>Sets the status of the process.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>callbacks</code>               (<code>Dict[Type[Callback], Callable]</code>)           \u2013            <p>Returns the dict of registered callbacks.</p> </li> <li> <code>context</code>               (<code>Context</code>)           \u2013            <p>Returns the shared context.</p> </li> <li> <code>errors</code>               (<code>List[ErrorProcess]</code>)           \u2013            <p>Returns the list of errors encountered during execution.</p> </li> <li> <code>status</code>               (<code>StatusProcess</code>)           \u2013            <p>Returns the current status of the process.</p> </li> </ul>"},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks.CheckLights.callbacks","title":"callbacks  <code>property</code>","text":"<pre><code>callbacks: Dict[Type[Callback], Callable]\n</code></pre> <p>Returns the dict of registered callbacks.</p>"},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks.CheckLights.context","title":"context  <code>property</code>","text":"<pre><code>context: Context\n</code></pre> <p>Returns the shared context.</p>"},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks.CheckLights.errors","title":"errors  <code>property</code>","text":"<pre><code>errors: List[ErrorProcess]\n</code></pre> <p>Returns the list of errors encountered during execution.</p>"},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks.CheckLights.status","title":"status  <code>property</code>","text":"<pre><code>status: StatusProcess\n</code></pre> <p>Returns the current status of the process.</p>"},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks.CheckLights.add_callback","title":"add_callback","text":"<pre><code>add_callback(callback_type: Callback, callback: callable) -&gt; None\n</code></pre> <p>Adds a callback function to be executed after the process finishes.</p>"},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks.CheckLights.add_error","title":"add_error","text":"<pre><code>add_error(error: Optional[str] = 'Unknown error', details: Optional[str] = 'Unknown details', items: Optional[List[str]] = None) -&gt; None\n</code></pre> <p>Adds an error to the list of errors.</p> <p>Parameters:</p>"},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks.CheckLights.add_error(error)","title":"<code>error</code>","text":"(<code>str</code>, default:                   <code>'Unknown error'</code> )           \u2013            <p>The error message or name.</p>"},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks.CheckLights.add_error(details)","title":"<code>details</code>","text":"(<code>str</code>, default:                   <code>'Unknown details'</code> )           \u2013            <p>Detailed description of the error.</p>"},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks.CheckLights.add_error(items)","title":"<code>items</code>","text":"(<code>list</code>, default:                   <code>None</code> )           \u2013            <p>Optional list of items related to the error.</p>"},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks.CheckLights.process","title":"process","text":"<pre><code>process(context: Context) -&gt; None\n</code></pre> <p>Checks whether all the dependencies has the environemnt variable in them.</p> <p>status : Bool errors : List errors = {\"text\":Informacion del error,\"list\":error_objects} error_objects : Error list objects = [node error, object] return : {\"status\":status,\"errors\":errors}</p>"},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks.CheckLights.set_status","title":"set_status","text":"<pre><code>set_status(status: StatusProcess) -&gt; None\n</code></pre> <p>Sets the status of the process.</p> <p>Parameters:</p>"},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks.CheckLights.set_status(status)","title":"<code>status</code>","text":"(<code>StatusProcess</code>)           \u2013            <p>Set status.</p>"},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks.CheckNodeHistory","title":"CheckNodeHistory","text":"<pre><code>CheckNodeHistory(manager: Manager)\n</code></pre> <p>Methods:</p> <ul> <li> <code>add_callback</code>             \u2013              <p>Adds a callback function to be executed after the process finishes.</p> </li> <li> <code>add_error</code>             \u2013              <p>Adds an error to the list of errors.</p> </li> <li> <code>process</code>             \u2013              <p>Checks whether all the nodes has the history clean.</p> </li> <li> <code>set_status</code>             \u2013              <p>Sets the status of the process.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>callbacks</code>               (<code>Dict[Type[Callback], Callable]</code>)           \u2013            <p>Returns the dict of registered callbacks.</p> </li> <li> <code>context</code>               (<code>Context</code>)           \u2013            <p>Returns the shared context.</p> </li> <li> <code>errors</code>               (<code>List[ErrorProcess]</code>)           \u2013            <p>Returns the list of errors encountered during execution.</p> </li> <li> <code>status</code>               (<code>StatusProcess</code>)           \u2013            <p>Returns the current status of the process.</p> </li> </ul>"},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks.CheckNodeHistory.callbacks","title":"callbacks  <code>property</code>","text":"<pre><code>callbacks: Dict[Type[Callback], Callable]\n</code></pre> <p>Returns the dict of registered callbacks.</p>"},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks.CheckNodeHistory.context","title":"context  <code>property</code>","text":"<pre><code>context: Context\n</code></pre> <p>Returns the shared context.</p>"},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks.CheckNodeHistory.errors","title":"errors  <code>property</code>","text":"<pre><code>errors: List[ErrorProcess]\n</code></pre> <p>Returns the list of errors encountered during execution.</p>"},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks.CheckNodeHistory.status","title":"status  <code>property</code>","text":"<pre><code>status: StatusProcess\n</code></pre> <p>Returns the current status of the process.</p>"},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks.CheckNodeHistory.add_callback","title":"add_callback","text":"<pre><code>add_callback(callback_type: Callback, callback: callable) -&gt; None\n</code></pre> <p>Adds a callback function to be executed after the process finishes.</p>"},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks.CheckNodeHistory.add_error","title":"add_error","text":"<pre><code>add_error(error: Optional[str] = 'Unknown error', details: Optional[str] = 'Unknown details', items: Optional[List[str]] = None) -&gt; None\n</code></pre> <p>Adds an error to the list of errors.</p> <p>Parameters:</p>"},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks.CheckNodeHistory.add_error(error)","title":"<code>error</code>","text":"(<code>str</code>, default:                   <code>'Unknown error'</code> )           \u2013            <p>The error message or name.</p>"},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks.CheckNodeHistory.add_error(details)","title":"<code>details</code>","text":"(<code>str</code>, default:                   <code>'Unknown details'</code> )           \u2013            <p>Detailed description of the error.</p>"},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks.CheckNodeHistory.add_error(items)","title":"<code>items</code>","text":"(<code>list</code>, default:                   <code>None</code> )           \u2013            <p>Optional list of items related to the error.</p>"},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks.CheckNodeHistory.process","title":"process","text":"<pre><code>process(context: Context) -&gt; None\n</code></pre> <p>Checks whether all the nodes has the history clean.</p> <p>status : Bool errors : List errors = {\"text\":Informacion del error,\"list\":error_objects} error_objects : Error list objects = [node error, object] return : {\"status\":status,\"errors\":errors}</p>"},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks.CheckNodeHistory.set_status","title":"set_status","text":"<pre><code>set_status(status: StatusProcess) -&gt; None\n</code></pre> <p>Sets the status of the process.</p> <p>Parameters:</p>"},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks.CheckNodeHistory.set_status(status)","title":"<code>status</code>","text":"(<code>StatusProcess</code>)           \u2013            <p>Set status.</p>"},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks.CheckOutlinerAssets","title":"CheckOutlinerAssets","text":"<pre><code>CheckOutlinerAssets(manager: Manager)\n</code></pre> <p>Methods:</p> <ul> <li> <code>__new__</code>             \u2013              <p>NOTE: the reason why we create these here is because this module</p> </li> <li> <code>add_callback</code>             \u2013              <p>Adds a callback function to be executed after the process finishes.</p> </li> <li> <code>add_error</code>             \u2013              <p>Adds an error to the list of errors.</p> </li> <li> <code>set_status</code>             \u2013              <p>Sets the status of the process.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>callbacks</code>               (<code>Dict[Type[Callback], Callable]</code>)           \u2013            <p>Returns the dict of registered callbacks.</p> </li> <li> <code>context</code>               (<code>Context</code>)           \u2013            <p>Returns the shared context.</p> </li> <li> <code>errors</code>               (<code>List[ErrorProcess]</code>)           \u2013            <p>Returns the list of errors encountered during execution.</p> </li> <li> <code>status</code>               (<code>StatusProcess</code>)           \u2013            <p>Returns the current status of the process.</p> </li> </ul>"},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks.CheckOutlinerAssets.callbacks","title":"callbacks  <code>property</code>","text":"<pre><code>callbacks: Dict[Type[Callback], Callable]\n</code></pre> <p>Returns the dict of registered callbacks.</p>"},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks.CheckOutlinerAssets.context","title":"context  <code>property</code>","text":"<pre><code>context: Context\n</code></pre> <p>Returns the shared context.</p>"},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks.CheckOutlinerAssets.errors","title":"errors  <code>property</code>","text":"<pre><code>errors: List[ErrorProcess]\n</code></pre> <p>Returns the list of errors encountered during execution.</p>"},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks.CheckOutlinerAssets.status","title":"status  <code>property</code>","text":"<pre><code>status: StatusProcess\n</code></pre> <p>Returns the current status of the process.</p>"},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks.CheckOutlinerAssets.__new__","title":"__new__","text":"<pre><code>__new__()\n</code></pre> <p>NOTE: the reason why we create these here is because this module is imported by a module that does not support maya environment, to inspect the checks and generate an UI. By hiding the maya_utils in the new() we defer the execution of those lines until a new instance is created, and these instances are only created in a Maya Env.</p>"},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks.CheckOutlinerAssets.add_callback","title":"add_callback","text":"<pre><code>add_callback(callback_type: Callback, callback: callable) -&gt; None\n</code></pre> <p>Adds a callback function to be executed after the process finishes.</p>"},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks.CheckOutlinerAssets.add_error","title":"add_error","text":"<pre><code>add_error(error: Optional[str] = 'Unknown error', details: Optional[str] = 'Unknown details', items: Optional[List[str]] = None) -&gt; None\n</code></pre> <p>Adds an error to the list of errors.</p> <p>Parameters:</p>"},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks.CheckOutlinerAssets.add_error(error)","title":"<code>error</code>","text":"(<code>str</code>, default:                   <code>'Unknown error'</code> )           \u2013            <p>The error message or name.</p>"},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks.CheckOutlinerAssets.add_error(details)","title":"<code>details</code>","text":"(<code>str</code>, default:                   <code>'Unknown details'</code> )           \u2013            <p>Detailed description of the error.</p>"},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks.CheckOutlinerAssets.add_error(items)","title":"<code>items</code>","text":"(<code>list</code>, default:                   <code>None</code> )           \u2013            <p>Optional list of items related to the error.</p>"},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks.CheckOutlinerAssets.set_status","title":"set_status","text":"<pre><code>set_status(status: StatusProcess) -&gt; None\n</code></pre> <p>Sets the status of the process.</p> <p>Parameters:</p>"},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks.CheckOutlinerAssets.set_status(status)","title":"<code>status</code>","text":"(<code>StatusProcess</code>)           \u2013            <p>Set status.</p>"},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks.CheckResidualAovs","title":"CheckResidualAovs","text":"<pre><code>CheckResidualAovs(manager: Manager)\n</code></pre> <p>Methods:</p> <ul> <li> <code>add_callback</code>             \u2013              <p>Adds a callback function to be executed after the process finishes.</p> </li> <li> <code>add_error</code>             \u2013              <p>Adds an error to the list of errors.</p> </li> <li> <code>process</code>             \u2013              <p>Checks whether all the dependencies has the environemnt variable in them.</p> </li> <li> <code>set_status</code>             \u2013              <p>Sets the status of the process.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>callbacks</code>               (<code>Dict[Type[Callback], Callable]</code>)           \u2013            <p>Returns the dict of registered callbacks.</p> </li> <li> <code>context</code>               (<code>Context</code>)           \u2013            <p>Returns the shared context.</p> </li> <li> <code>errors</code>               (<code>List[ErrorProcess]</code>)           \u2013            <p>Returns the list of errors encountered during execution.</p> </li> <li> <code>status</code>               (<code>StatusProcess</code>)           \u2013            <p>Returns the current status of the process.</p> </li> </ul>"},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks.CheckResidualAovs.callbacks","title":"callbacks  <code>property</code>","text":"<pre><code>callbacks: Dict[Type[Callback], Callable]\n</code></pre> <p>Returns the dict of registered callbacks.</p>"},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks.CheckResidualAovs.context","title":"context  <code>property</code>","text":"<pre><code>context: Context\n</code></pre> <p>Returns the shared context.</p>"},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks.CheckResidualAovs.errors","title":"errors  <code>property</code>","text":"<pre><code>errors: List[ErrorProcess]\n</code></pre> <p>Returns the list of errors encountered during execution.</p>"},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks.CheckResidualAovs.status","title":"status  <code>property</code>","text":"<pre><code>status: StatusProcess\n</code></pre> <p>Returns the current status of the process.</p>"},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks.CheckResidualAovs.add_callback","title":"add_callback","text":"<pre><code>add_callback(callback_type: Callback, callback: callable) -&gt; None\n</code></pre> <p>Adds a callback function to be executed after the process finishes.</p>"},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks.CheckResidualAovs.add_error","title":"add_error","text":"<pre><code>add_error(error: Optional[str] = 'Unknown error', details: Optional[str] = 'Unknown details', items: Optional[List[str]] = None) -&gt; None\n</code></pre> <p>Adds an error to the list of errors.</p> <p>Parameters:</p>"},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks.CheckResidualAovs.add_error(error)","title":"<code>error</code>","text":"(<code>str</code>, default:                   <code>'Unknown error'</code> )           \u2013            <p>The error message or name.</p>"},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks.CheckResidualAovs.add_error(details)","title":"<code>details</code>","text":"(<code>str</code>, default:                   <code>'Unknown details'</code> )           \u2013            <p>Detailed description of the error.</p>"},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks.CheckResidualAovs.add_error(items)","title":"<code>items</code>","text":"(<code>list</code>, default:                   <code>None</code> )           \u2013            <p>Optional list of items related to the error.</p>"},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks.CheckResidualAovs.process","title":"process","text":"<pre><code>process(context: Context) -&gt; None\n</code></pre> <p>Checks whether all the dependencies has the environemnt variable in them.</p> <p>status : Bool errors : List errors = {\"text\":Informacion del error,\"list\":error_objects} error_objects : Error list objects = [node error, object] return : {\"status\":status,\"errors\":errors}</p>"},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks.CheckResidualAovs.set_status","title":"set_status","text":"<pre><code>set_status(status: StatusProcess) -&gt; None\n</code></pre> <p>Sets the status of the process.</p> <p>Parameters:</p>"},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks.CheckResidualAovs.set_status(status)","title":"<code>status</code>","text":"(<code>StatusProcess</code>)           \u2013            <p>Set status.</p>"},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks.CheckSequenceManager","title":"CheckSequenceManager","text":"<pre><code>CheckSequenceManager(manager: Manager)\n</code></pre> <p>Methods:</p> <ul> <li> <code>add_callback</code>             \u2013              <p>Adds a callback function to be executed after the process finishes.</p> </li> <li> <code>add_error</code>             \u2013              <p>Adds an error to the list of errors.</p> </li> <li> <code>process</code>             \u2013              <p>Checks whether all the dependencies has the environemnt variable in them.</p> </li> <li> <code>set_status</code>             \u2013              <p>Sets the status of the process.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>callbacks</code>               (<code>Dict[Type[Callback], Callable]</code>)           \u2013            <p>Returns the dict of registered callbacks.</p> </li> <li> <code>context</code>               (<code>Context</code>)           \u2013            <p>Returns the shared context.</p> </li> <li> <code>errors</code>               (<code>List[ErrorProcess]</code>)           \u2013            <p>Returns the list of errors encountered during execution.</p> </li> <li> <code>status</code>               (<code>StatusProcess</code>)           \u2013            <p>Returns the current status of the process.</p> </li> </ul>"},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks.CheckSequenceManager.callbacks","title":"callbacks  <code>property</code>","text":"<pre><code>callbacks: Dict[Type[Callback], Callable]\n</code></pre> <p>Returns the dict of registered callbacks.</p>"},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks.CheckSequenceManager.context","title":"context  <code>property</code>","text":"<pre><code>context: Context\n</code></pre> <p>Returns the shared context.</p>"},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks.CheckSequenceManager.errors","title":"errors  <code>property</code>","text":"<pre><code>errors: List[ErrorProcess]\n</code></pre> <p>Returns the list of errors encountered during execution.</p>"},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks.CheckSequenceManager.status","title":"status  <code>property</code>","text":"<pre><code>status: StatusProcess\n</code></pre> <p>Returns the current status of the process.</p>"},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks.CheckSequenceManager.add_callback","title":"add_callback","text":"<pre><code>add_callback(callback_type: Callback, callback: callable) -&gt; None\n</code></pre> <p>Adds a callback function to be executed after the process finishes.</p>"},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks.CheckSequenceManager.add_error","title":"add_error","text":"<pre><code>add_error(error: Optional[str] = 'Unknown error', details: Optional[str] = 'Unknown details', items: Optional[List[str]] = None) -&gt; None\n</code></pre> <p>Adds an error to the list of errors.</p> <p>Parameters:</p>"},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks.CheckSequenceManager.add_error(error)","title":"<code>error</code>","text":"(<code>str</code>, default:                   <code>'Unknown error'</code> )           \u2013            <p>The error message or name.</p>"},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks.CheckSequenceManager.add_error(details)","title":"<code>details</code>","text":"(<code>str</code>, default:                   <code>'Unknown details'</code> )           \u2013            <p>Detailed description of the error.</p>"},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks.CheckSequenceManager.add_error(items)","title":"<code>items</code>","text":"(<code>list</code>, default:                   <code>None</code> )           \u2013            <p>Optional list of items related to the error.</p>"},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks.CheckSequenceManager.process","title":"process","text":"<pre><code>process(context: Context) -&gt; None\n</code></pre> <p>Checks whether all the dependencies has the environemnt variable in them.</p> <p>status : Bool errors : List errors = {\"text\":Informacion del error,\"list\":error_objects} error_objects : Error list objects = [node error, object] return : {\"status\":status,\"errors\":errors}</p>"},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks.CheckSequenceManager.set_status","title":"set_status","text":"<pre><code>set_status(status: StatusProcess) -&gt; None\n</code></pre> <p>Sets the status of the process.</p> <p>Parameters:</p>"},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks.CheckSequenceManager.set_status(status)","title":"<code>status</code>","text":"(<code>StatusProcess</code>)           \u2013            <p>Set status.</p>"},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks.CheckStarLike","title":"CheckStarLike","text":"<pre><code>CheckStarLike(manager: Manager)\n</code></pre> <p>Starlike polygons are a type of nGons, where the angles between the edges meet certain criteria. This check is deprecated for now on in Grisu pipeline.</p> <p>Methods:</p> <ul> <li> <code>add_callback</code>             \u2013              <p>Adds a callback function to be executed after the process finishes.</p> </li> <li> <code>add_error</code>             \u2013              <p>Adds an error to the list of errors.</p> </li> <li> <code>fix_method</code>             \u2013              <p>Provides a method to fix issues detected by the check.</p> </li> <li> <code>set_status</code>             \u2013              <p>Sets the status of the process.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>callbacks</code>               (<code>Dict[Type[Callback], Callable]</code>)           \u2013            <p>Returns the dict of registered callbacks.</p> </li> <li> <code>context</code>               (<code>Context</code>)           \u2013            <p>Returns the shared context.</p> </li> <li> <code>errors</code>               (<code>List[ErrorProcess]</code>)           \u2013            <p>Returns the list of errors encountered during execution.</p> </li> <li> <code>status</code>               (<code>StatusProcess</code>)           \u2013            <p>Returns the current status of the process.</p> </li> </ul>"},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks.CheckStarLike.callbacks","title":"callbacks  <code>property</code>","text":"<pre><code>callbacks: Dict[Type[Callback], Callable]\n</code></pre> <p>Returns the dict of registered callbacks.</p>"},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks.CheckStarLike.context","title":"context  <code>property</code>","text":"<pre><code>context: Context\n</code></pre> <p>Returns the shared context.</p>"},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks.CheckStarLike.errors","title":"errors  <code>property</code>","text":"<pre><code>errors: List[ErrorProcess]\n</code></pre> <p>Returns the list of errors encountered during execution.</p>"},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks.CheckStarLike.status","title":"status  <code>property</code>","text":"<pre><code>status: StatusProcess\n</code></pre> <p>Returns the current status of the process.</p>"},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks.CheckStarLike.add_callback","title":"add_callback","text":"<pre><code>add_callback(callback_type: Callback, callback: callable) -&gt; None\n</code></pre> <p>Adds a callback function to be executed after the process finishes.</p>"},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks.CheckStarLike.add_error","title":"add_error","text":"<pre><code>add_error(error: Optional[str] = 'Unknown error', details: Optional[str] = 'Unknown details', items: Optional[List[str]] = None) -&gt; None\n</code></pre> <p>Adds an error to the list of errors.</p> <p>Parameters:</p>"},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks.CheckStarLike.add_error(error)","title":"<code>error</code>","text":"(<code>str</code>, default:                   <code>'Unknown error'</code> )           \u2013            <p>The error message or name.</p>"},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks.CheckStarLike.add_error(details)","title":"<code>details</code>","text":"(<code>str</code>, default:                   <code>'Unknown details'</code> )           \u2013            <p>Detailed description of the error.</p>"},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks.CheckStarLike.add_error(items)","title":"<code>items</code>","text":"(<code>list</code>, default:                   <code>None</code> )           \u2013            <p>Optional list of items related to the error.</p>"},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks.CheckStarLike.fix_method","title":"fix_method","text":"<pre><code>fix_method() -&gt; None\n</code></pre> <p>Provides a method to fix issues detected by the check.</p>"},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks.CheckStarLike.set_status","title":"set_status","text":"<pre><code>set_status(status: StatusProcess) -&gt; None\n</code></pre> <p>Sets the status of the process.</p> <p>Parameters:</p>"},{"location":"dev/publisher/utils/maya_checks/#utils.maya_checks.CheckStarLike.set_status(status)","title":"<code>status</code>","text":"(<code>StatusProcess</code>)           \u2013            <p>Set status.</p>"},{"location":"dev/task_schema/","title":"Index","text":""},{"location":"dev/task_schema/#task-schema","title":"Task Schema","text":"<p>The task schema defines how the task folders will be grouped together, it is essentially a blue print that the task plugin will abide to. The task schema is essentially the file system format, and it is primarly composed of two parts: the task input and the task plugin.</p>"},{"location":"dev/task_schema/#task-input","title":"Task Input","text":"<p>This is essentially a list of tasks formated as a json, with both compulsory and non-compulsory fields. Many of these fields will be gathered form either a hardcoded list or a method for gathering this list from somewhere else defined in the  plugin.</p> <ol> <li>Compulsory fields: those fields that are needed for keeping the tools functioning as expected. These are defined by developers.</li> <li>local_root: the local root of the file system. Can -should- be a environment variable.</li> <li>server_root: the server root of the file system. Can -should- be a environment variable.</li> <li>directory: an upstream hardcoded directory of folders, or a method of making up the parent folders from compulsory fields.</li> <li>name: the name of the task. This is the name of the folder of this task.</li> <li>Project fields: project relative compulsory fields.Compulsory elements that may be re-define for each project.</li> <li>entity: generally a task would belong to an specific entity from the following list: episode, sequence, shot, asset. This is useful for sorting.</li> <li>assignee: a list of people the task is assigned to.</li> <li>Optional fields: those that will allow for non-critical and additional tool functionality. Some optional fields may become compulsory depending on each pipeline. These fields are usually handly for sorting and filtering purposes.</li> <li>subfolders: a list of folders that are contained withing the \"task folder\".</li> <li>id: the unique identifyer for this task. May be defined by the plugin.</li> </ol>"},{"location":"dev/task_schema/#task-plugin","title":"Task plugin","text":"<p>This is an utility that allows for the translation of the raw input data into Task Input friendly data. This is where the programing work is done and it has to be crafted for each input each time every input changes. So there will be one plugin for input comming from Shotgrid, another one for data comming from and Excel, Google Sheets etc. There should be only one plugin used for each project and no more than one plugin should be used as it would mean that the project doesn't have a centralized data base.</p>"},{"location":"dev/task_schema/examples/","title":"Examples","text":""},{"location":"dev/task_schema/examples/#developing-a-custom-production-plugin","title":"Developing a Custom Production Plugin","text":"<p>This guide walks you through the process of creating a custom production plugin for the GwaIO ecosystem. Plugins are essential for tailoring GwaIO to your specific pipeline needs, integrating with production tracking systems, and defining project-specific workflows.</p> <p>In this example, we will focus on building a plugin based on the <code>ShotgridPlugin</code> class. This provides a robust foundation by leveraging the pre-existing logic for communication between GwaIO and Autodesk ShotGrid.</p>"},{"location":"dev/task_schema/examples/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, ensure you have the following set up in your development environment:</p> <ul> <li>GwaIO Repositories: You must have the core GwaIO repositories installed or accessible in your <code>PYTHONPATH</code>:<ul> <li><code>launcher</code></li> <li><code>task_schema</code></li> <li><code>utilities</code></li> <li><code>publisher</code></li> </ul> </li> <li>Python Version: GwaIO requires <code>Python 3.10.14</code>. Please ensure you have this specific version installed and active.</li> </ul> <p>Info</p> <p>This guide assumes a basic understanding of Python programming and familiarity with both the GwaIO ecosystem and Autodesk ShotGrid concepts.</p>"},{"location":"dev/task_schema/examples/#1-create-your-plugin-file","title":"1. Create Your Plugin File \ud83d\udcdd","text":"<p>The first step is to create a Python file that will contain your plugin's code. For this guide, we will name our file <code>production_plugin.py</code>.</p> <p>According to the GwaIO structure, this file should be placed within the <code>plugins</code> directory of the <code>task_schema</code> repository.</p> <p>Path: <code>task_schema/plugins/production_plugin.py</code></p> <p>Filename: <code>production_plugin.py</code></p> <p>Note</p> <p>While the example suggests this specific path, you might have a different or centralized location for custom plugins in your studio's GwaIO deployment. Ensure the GwaIO <code>launcher</code> can discover and load your plugin from its location.</p>"},{"location":"dev/task_schema/examples/#2-define-necessary-imports","title":"2. Define Necessary Imports","text":"<p>At the very beginning of your <code>production_plugin.py</code> file, add all the necessary import statements. These will bring in the core GwaIO classes your plugin will extend or interact with, along with any standard Python libraries, UI elements, publisher components, or custom utilities your specific workflow requires.</p> <pre><code># production_plugin.py\nfrom pathlib import Path\nfrom typing import Iterable\nimport traceback\nfrom shutil import copy2\nfrom os import remove, fspath\nimport pandas\nfrom difflib import SequenceMatcher as smatch\nfrom re import sub\n\n# --- GwaIO Core Imports ---\n# Import the base classes. We inherit from ShotgridPlugin, \n# BaseTask represents a task in GwaIO.\nfrom task_schema.plugins.shotgrid_plugin import ShotgridPlugin, BaseTask \n\n# --- Optional UI Imports ---\n# Import UI elements like custom toolbars if your plugin adds them.\nfrom launcher.qtclasses.toolbar_maya import MayaToolbar \n\n# --- Optional Publisher Imports ---\n# Import base classes if you're integrating with the GwaIO Publisher framework.\n# Replace with your actual Collect/Push classes.\nfrom publisher.core import Collect, Push \n\n# --- Optional Utility Imports ---\n# Import any helper scripts or batch processes your plugin might use.\nfrom utilities.maya.scripts import (\n    batch_playblast,\n    batch_turntable,\n)\n</code></pre> <p>Adapt Your Imports</p> <p>The imports shown above are based on the example plugin. You should tailor this section to include only what your specific plugin needs. If you aren't using Maya toolbars or specific publisher classes, you won't need those imports. Conversely, if you're working with Nuke or Houdini, you might import their respective toolbars or utilities.</p>"},{"location":"dev/task_schema/examples/#3-plugin-class-definition","title":"3. Plugin Class Definition","text":"<p>Next, define your plugin class. In our example, we're creating <code>ProductionPlugin</code> which inherits from <code>ShotgridPlugin</code>. If you're not integrating with ShotGrid, you might inherit from <code>BasePlugin</code> directly.</p> <p>Key class-level attributes to set initially include:</p> <ul> <li><code>title</code>: A human-readable name for your plugin, often used in UIs.</li> <li><code>SG_PROJECT_ID</code> (if using <code>ShotgridPlugin</code>): The numerical ID of your ShotGrid project.</li> <li><code>SHOTGRID_URL</code> (if using <code>ShotgridPlugin</code>): The base URL of your ShotGrid instance.</li> </ul> <p>The <code>__init__</code> method is where you'll initialize instance variables and configure the plugin's behavior. This is the primary area for setting up all necessary variables for the plugin and its associated tools to function correctly.</p> <p>Review Base Class Documentation</p> <p>You can review the default configuration variables used in <code>BasePlugin</code> and <code>ShotgridPlugin</code> by referring to their respective documentation (we can add links here later if available, e.g., <code>[BasePlugin](path/to/base_plugin_doc.md)</code> and <code>[ShotgridPlugin](path/to/shotgrid_plugin_doc.md)</code>).</p> <pre><code>class ProductionPlugin(ShotgridPlugin):\n    title = \"Production Project\"  # A descriptive title for UI purposes\n    SG_PROJECT_ID = 999  # Example ShotGrid Project ID\n    SHOTGRID_URL = \"https://yourstudio.shotgunstudio.com\"  # Your ShotGrid instance URL\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n        # ----------------------------------------------------------------------\n        # GwaIO Launcher Configuration\n        # ----------------------------------------------------------------------\n        # Defines GwaIO Launcher behavior, UI elements, and available actions.\n\n        # Default entity types and filters to apply when the plugin loads in the launcher.\n        self._active_entities = [\"My Tasks\", \"Asset\", \"Sequence\", \"Episode\", \"Shot\"]\n\n        # List of custom job functions/classes available through the launcher UI.\n        # These are typically batch processes or automated tasks.\n        self._jobs += [\n            batch_playblast,\n            batch_turntable,\n        ]\n\n        # Define custom toolbars to be added to the launcher UI for this plugin.\n        # Each item is a list: [ToolbarClass, \"Display Name\", \"Placement (e.g., 'right')\"]\n        self._toolbars += [\n            [MayaToolbar, \"Maya Toolbar\", \"right\"],\n        ]\n\n        # Default entity type and filters to apply when adding tasks to the view (e.g. \"My Tasks\" view).\n        self.add_tasks_from_plugin_kwargs = {\"sg_entity_type\": \"My Tasks\"}\n\n        # File extensions offered in the \"Create File\" dialog.\n        # \"from selected\" implies using the current task context for creation.\n        self.create_file_ext = [\"from selected\", \"psd\", \"ma\", \"spp\", \"xlsx\"]\n\n        # Flag indicating if the project uses a render farm like Deadline.\n        self.uses_deadline = True\n\n        # ----------------------------------------------------------------------\n        # ShotGrid Integration Configuration\n        # ----------------------------------------------------------------------\n        # Settings specific to how GwaIO interacts with ShotGrid.\n\n        # --- ShotGrid Custom Artist Entity Configuration ---\n        # Maps launcher users to a specific Artist entity in ShotGrid.\n        # Field on your Artist Custom Entity in SG that matches the launcher username.\n        self.custom_artist_entity_name = \"CustomEntity04\" \n        self.custom_artist_login_field = \"code\" # Login field on the custom artist entity.\n\n        # Fields on various ShotGrid entities that link back to your Artist Custom Entity.\n        self.publishedfile_artist_entity_field = \"sg_mondo_artist\"  # On PublishedFile\n        self.timelog_artist_entity_field = \"sg_mondo_artist\"       # On TimeLog\n        self.version_artist_entity_field = \"sg_mondo_artist\"       # On Version\n        self.custom_artist_task_field = \"sg_mondo_artist\"          # On Task (for assignments)\n\n        # Extend or refine the default ShotGrid task filters.\n        # These filters apply when fetching tasks from ShotGrid.\n        self.plugin_task_filters += [\n            [\"sg_status_list\", \"not_in\", [\"na\", \"wtg\"]],\n            [\"entity.Asset.sg_status_list\", \"not_in\", [\"na\"]],\n        ]\n\n        # Default ShotGrid status to assign to newly uploaded Versions (e.g., \"rev\" for \"Pending Review\").\n        self._upload_status = \"rev\"\n\n        # ----------------------------------------------------------------------\n        # File System Configuration\n        # ----------------------------------------------------------------------\n        # Defines project paths, naming conventions, and template locations.\n\n        # Local root path for the project. Reads \"PRODUCTION_LOCAL_PATH\" environment variable.\n        self._local_root = Path(self.env_handler.get_env(\"PRODUCTION_LOCAL_PATH\"))\n\n        # Server root path for the project. Reads \"PRODUCTION_SERVER_PATH\" env var, or uses a hardcoded path.\n        self._server_root = Path(\n            self.env_handler.get_env(\n                \"PRODUCTION_SERVER_PATH\",\n                # Default hardcoded path if environment variable is not set\n                Path(\"\\\\\\\\qsrv01.mondotvcanarias.lan\\\\proj_production\\\\Production\") \n            )\n        )\n\n        # Path to project file templates.\n        self.TEMPLATES_FOLDER = Path(self._server_root, \"production/publish/templates\")\n\n        # Path to a studio library (e.g., animation library).\n        self.SL_SERVER_PATH = Path(self._server_root, \"production/publish/library/anim_lib\")\n\n        # Relative path within a task's local directory where previews (thumbnails, playblasts) are stored.\n        # If Path(), previews are at the root of the task's local_path.\n        self._preview_location = Path() \n\n        # If True, the entity's code (e.g., asset/shot name) must be part of the versioned filename.\n        self._version_includes_entity = True\n\n        # Regex to extract version numbers from filenames (e.g., gets '001' from 'file_w001.ma').\n        self.version_regex = r\"(?&lt;=_[wv])\\d{3}\" \n\n        # List of regex patterns to validate filenames against project conventions.\n        # \"prd\" is an example prefix; adapt these to your project's specific naming scheme.\n        self._naming_regex = [\n            r\"^prd_[a-z]{2}_[A-Za-z0-9]+_[A-Za-z0-9]+_[a-z]+_[wv]\\d{3}.*\",\n            r\"^prd(_\\d{3})_([a-z]+)_[wv]\\d{3}.*\",\n            r\"^prd(_\\d{3}){2}_([a-z]+)_[wv]\\d{3}.*\",\n            r\"^prd(_\\d{3}){3}_([a-z]+)_[wv]\\d{3}.*\",\n            r\"^prd(_\\d{3}){3}(_[a-z]+){1,3}_[wv]\\d{3}.*\",\n        ]\n        # Regular expression to validate BDL (Bill of Data List) filenames.\n        self.bdlregex = r\"prd_(\\d{3}_|[a-zA-Z]{2}_([a-zA-Z09]*._){2})bd[lw]_[vw]\\d{3}\\.xlsx\"\n\n        # Base path for asset work directories.\n        # Note: fspath is from 'os' module, ensure it's imported if you use it.\n        self._asset_folder = fspath(self.local_root) + \"/PROD/assets/work\"\n\n        # Regex to help an asset browser find asset work folders.\n        self._asset_folder_regex = fspath(self.local_root) + \"/PROD/assets/work/*/*/*\"\n\n        # Provides default template files. Used by methods like return_next_version_name.\n        self._dict_file_templates = {\n            \"bdl\": Path(self.TEMPLATES_FOLDER, \"prd_template_bdl.xlsx\"),\n            \"bdw\": Path(self.TEMPLATES_FOLDER, \"prd_template_bdl.xlsx\"),\n            \"skt\": Path(self.TEMPLATES_FOLDER, \"prd_template_psd.psd\"),\n        }\n\n        # ----------------------------------------------------------------------\n        # DCC Application Configuration\n        # ----------------------------------------------------------------------\n        # Settings related to Digital Content Creation (DCC) applications.\n\n        # Paths to shared custom scripts, plugins, or shelves for DCCs.\n        # These are often added to environment variables in `generate_environment_for_app()`.\n        self.CUSTOM_MAYA_TOOLS = Path(self.server_root, \"pipeline/publish/dev/maya\")\n        self.CUSTOM_NUKE_TOOLS = Path(self.server_root, \"pipeline/publish/dev/nuke\")\n\n        # ----------------------------------------------------------------------\n        # Project-Specific Configuration\n        # ----------------------------------------------------------------------\n        # General project settings like frame rates and task dependencies.\n\n        self._fps = 25  # Frames per second for the project.\n        self._starting_frame = 101  # Default start frame for animation, playblasts, etc.\n\n        # --- Previous Task Mapping ---\n        # Defines dependencies: maps a current task name to its typical upstream task.\n        # Used to find outputs from previous steps (e.g., model from blocking for rigging).\n        # Key: current task's long SG name. Value: dict {task_name: prev_task_long_SG_name, step: prev_task_SG_Step_code}.\n        self._dict_previous_tasks = {\n            \"line\": {\"task\": \"sketch\", \"step\": \"ConceptArtStep\"},\n            \"color\": {\"task\": \"line\", \"step\": \"ConceptArtStep\"},\n            \"model\": {\"task\": \"blocking\", \"step\": \"ModelingStep\"},\n            \"uvs\": {\"task\": \"model\", \"step\": \"ModelingStep\"},\n        }\n\n        # ----------------------------------------------------------------------\n        # EDL (Edit Decision List) Configuration\n        # ----------------------------------------------------------------------\n        # Settings for EDL processing workflows.\n\n        self._edl_target_task = \"animatic\"  # Default SG Task name for EDL processing.\n        self._edl_task_name = \"EDL\" # Name of the EDL task itself.\n        self._edl_shot_prefix = \"\" # Prefix for shot names extracted from EDL.\n        self._edl_sequence_prefix = \"\" # Prefix for sequence names.\n        self._edl_episode_prefix = \"plt_\" # Prefix for episode names.\n        self.edl_sequence_regex = compile(r\"(?&lt;=plt_)\\d{3}_\\d{3}\") # Regex to parse sequence codes.\n        self._edl_shot_regex = compile(r\"(?&lt;=plt_)\\d{3}_\\d{3}_\\d{3}\") # Regex to parse shot codes.\n        self.edl_version_regex = compile(r\"(?&lt;=_[VvWw])\\d{3}\") # Regex for version numbers in EDL context.\n        self._shot_task_tpl_id = 1069 # ShotGrid Task Template ID for EDL-created tasks.\n        self._episode_edl_workflow = True # Flag to enable episode-based EDL workflow.\n        self._edl_episode_regex = compile(r\"plt_\\d{3}\") # Regex to parse episode codes.\n\n        # ----------------------------------------------------------------------\n        # Publisher Framework Configuration\n        # ----------------------------------------------------------------------\n        # Defines how the GwaIO Publisher Framework interacts with this plugin.\n\n        # Configures the publisher UI by mapping task types (ShotGrid task names) \n        # to sets of Collector and Pusher classes from the Publisher framework.\n        self.publisher_builder_data = {\n            \"line\": {  # Example for a 'line' task\n                CollectTask,\n                CollectFileConcept,\n                CollectPreview,\n                CollectBID,\n                CollectDescription,\n                PushSG,\n            },\n            \"color\": { # Example for a 'color' task\n                CollectTask,\n                CollectFileConcept,\n                CollectPreview,\n                CollectBID,\n                CollectDescription,\n                PushSG,\n            },\n            \"sbRough\": { # Example for a 'storyboard rough' task\n                CollectTask,\n                CollectFileVideo,\n                CollectPreviewVideo,\n                CollectBID,\n                PushSG,\n            },\n            \"model\": { # Example for a 'model' task\n                CollectTask,\n                CollectFileVideo, # Assuming 3D model tasks might also have video reviews (e.g. turntables)\n                CollectPreviewVideo,\n                CollectBID, # Business ID or other metadata collection\n                PushSG, # Pushes data to ShotGrid\n            },\n        }\n</code></pre> <p>Explore Base Classes</p> <p>Many default configurations and methods are inherited. Refer to the documentation for BasePlugin and ShotgridPlugin to understand all available options and their default behaviors.</p>"},{"location":"dev/task_schema/examples/#31-gwaio-configuration","title":"3.1 GwaIO Configuration","text":"<p>This section details the configuration variables that impact the GwaIO interface, allowing for the integration of custom toolbars and jobs within your personalized plugin.</p> <ul> <li>Custom Toolbars: You can integrate DCC (Digital Content Creation) application-specific toolbars, such as <code>MayaToolbar</code> (potentially provided by <code>launcher.qtclasses.toolbar_maya</code>) or your own custom toolbar classes, by adding them to the <code>self._toolbars</code> list within your plugin's <code>__init__</code> method. These toolbars will appear in the GwaIO launcher UI, providing buttons and actions that are contextual to the selected task and the integrated DCC application.</li> </ul> <p>To learn more about creating custom toolbars, refer to the <code>BaseToolbars</code> documentation.</p> <ul> <li>Custom Jobs: For pipeline batch processes, such as playblasting, rendering via Deadline, or executing QA scripts using <code>mayapy</code>, you can define these as Python functions or classes. These callable jobs should then be listed in the <code>self._jobs</code> list during your plugin's <code>__init__</code> method. The GwaIO launcher application will then provide a user interface to select and trigger these jobs, often passing the current task context to them.</li> </ul> <p>The following imports are necessary for integrating custom toolbars and jobs:</p> <pre><code>from launcher.qtclasses.toolbar_maya import MayaToolbar # Optional: UI elements like toolbars\nfrom utilities.maya.scripts import (\n    batch_playblast,\n    batch_turntable,\n) # Optional: Utilities\n\nEstas ser\u00edan las variables del ejemplo\n```py\n        ...\n        super().__init__(*args, **kwargs)\n\n        ################\n        # GwaIO Config #\n        ################\n\n        self._active_entities = [\"My Tasks\", \"Asset\", \"Sequence\", \"Episode\", \"Shot\"] # Default entity type and filters to apply when the plugin loads in the launcher. \n        self._jobs += [\n            batch_playblast,\n            batch_turntable,\n        ]\n        # Define custom toolbars to be added to the launcher UI for this plugin.  \n        # Each item is a list: [ToolbarClass, \"Display Name\", \"Placement (e.g., 'right')\"]\n        self._toolbars += [\n            [MayaToolbar, \"Maya Toolbar\", \"right\"],\n        ]\n        self.add_tasks_from_plugin_kwargs = {\"sg_entity_type\": \"My Tasks\"} # Default entity type and filters to apply when the plugin loads in the launcher. \n        self.create_file_ext = [\"from selected\", \"psd\", \"ma\", \"spp\", \"xlsx\"] # File extensions offered in the \"Create File\" dialog. \"from selected\" implies using the current task context. \n        self.uses_deadline = True # Flag indicating if the project uses a render farm like Deadline. \n</code></pre>"},{"location":"dev/task_schema/examples/#32-shotgrid-config","title":"3.2 Shotgrid Config","text":"<p>This section fine-tunes the interaction with ShotGrid.</p> <ul> <li>Custom Artist Entity: If you use a custom entity in ShotGrid to represent artists/users (instead of the standard HumanUser), these variables (<code>custom_artist_entity_name</code>, <code>custom_artist_login_field</code>, etc.) map GwaIO users to that entity for tasks, versions, and timelogs.</li> <li><code>plugin_task_filters</code>: Allows you to add more filters to the ones already defined in <code>ShotgridPlugin</code>. These are used when fetching tasks from ShotGrid, helping to narrow down the list shown to users (e.g., hiding tasks with 'N/A' or 'Waiting to Start' statuses).</li> <li><code>_upload_status</code>: Sets the default ShotGrid status (e.g., 'rev' for 'Pending Review') that will be assigned to new Version entities created by GwaIO.</li> </ul> <pre><code>        ...\n\n        #############\n        # SG Config #\n        #############\n\n        # --- ShotGrid Custom Artist Entity Configuration ---  \n        # Defines how launcher users are mapped to your specific Artist entity in ShotGrid.  \n        self.custom_artist_entity_name = \"CustomEntity04\"  # Field on your Artist Custom Entity in SG that matches the launcher username.\n        self.custom_artist_login_field = \"code\"\n        # Fields on various ShotGrid entities that link back to your Artist Custom Entity.\n        self.publishedfile_artist_entity_field = \"sg_mondo_artist\" # On PublishedFile  \n        self.timelog_artist_entity_field = \"sg_mondo_artist\"       # On TimeLog  \n        self.version_artist_entity_field = \"sg_mondo_artist\"       # On Version  \n        self.custom_artist_task_field = \"sg_mondo_artist\"          # On Task (for assignments)\n        # Extend or refine the default ShotGrid task filters inherited from ShotgridPlugin.  \n        # These filters apply when fetching tasks from ShotGrid.  \n        self.plugin_task_filters += [\n            [\"sg_status_list\", \"not_in\", [\"na\", \"wtg\"]],\n            [\"entity.Asset.sg_status_list\", \"not_in\", [\"na\"]],\n        ]\n        # Default ShotGrid status to assign to newly uploaded Versions (e.g., \"rev\" for \"Pending Review\").  \n        self._upload_status = \"rev\"\n\n        ...\n</code></pre> <p>Custom ShotGrid Scripts</p> <p>If you need to use different or custom scripts for managing ShotGrid interactions (beyond what <code>ShotgridPlugin</code> provides), explore its methods and override them. You can also define specific <code>sg_</code> attributes to point to your custom ShotGrid API handlers if needed.</p>"},{"location":"dev/task_schema/examples/#33-file-system-configuration","title":"3.3 File System Configuration","text":"<p>This section defines how GwaIO understands and interacts with your project's directory structure and naming conventions.</p> <ul> <li><code>_local_root</code> / <code>_server_root</code>: Defines the base paths for local work and server-side storage. Using <code>self.env_handler.get_env()</code> is recommended, allowing flexibility through environment variables with sensible fallbacks.</li> <li><code>TEMPLATES_FOLDER</code> / <code>SL_SERVER_PATH</code>: Paths to specific shared resources like file templates or studio libraries.</li> <li><code>_preview_location</code>: Specifies a sub-folder within a task's directory for storing previews. An empty <code>Path()</code> means previews go to the task's root.</li> <li><code>version_regex</code> / <code>_naming_regex</code> / <code>bdlregex</code>: Regular expressions are crucial for GwaIO to parse version numbers from filenames and to validate that filenames adhere to your studio's naming conventions.</li> <li><code>_asset_folder</code> / <code>_asset_folder_regex</code>: Helps tools like the asset browser locate asset work directories efficiently.</li> <li><code>_dict_file_templates</code>: Maps short task names (or other keys) to specific template files. This is used by <code>return_next_version_name</code> when creating the very first version of a file for a task.</li> </ul> <pre><code>        ...\n        ######################\n        # File System Config #\n        ######################\n\n        # Set the local root path for the project.  \n        # Reads \"PRODUCTION_LOCAL_PATH\" env var\n        self._local_root = Path(self.env_handler.get_env(\"PRODUCTION_LOCAL_PATH\"))\n         # Set the server root path for the project.  \n        # Reads \"PRODUCTION_SERVER_PATH\" env var, or uses hardcode path\n        self._server_root = Path(\n            self.env_handler.get_env(\n                \"PRODUCTION_SERVER_PATH\",\n                Path(\n                    \"\\\\\\\\qsrv01.mondotvcanarias.lan\\\\proj_production\\\\Production\"\n                ),\n            )\n        )\n        self.TEMPLATES_FOLDER = Path(self._server_root, \"production/publish/templates\") # Path to project file templates. \n        self.SL_SERVER_PATH = Path(self._server_root, \"production/publish/library/anim_lib\") # Path to a studio library. \n\n        # Relative path within a task's local directory where previews (e.g., thumbnails, playblasts) are stored.  \n        # If Path(), previews are at the root of the task's local_path.  \n        self._preview_location = Path()\n        # If True, the entity's code (e.g., asset/shot name) must be part of the versioned filename. \n        self._version_includes_entity = True\n        # Regex to extract version numbers from filenames (e.g., gets '001' from 'file_w001.ma'). \n        self.version_regex = r\"(?&lt;=_[wv])\\d\\d\\d\"\n        # List of regex patterns to validate filenames against project conventions.  \n        # \"prd\" is an example prefix; adapt these to your project's specific naming scheme. \n        self._naming_regex = [\n            r\"^prd_[a-z]{2}_[A-Za-z0-9]+_[A-Za-z0-9]+_[a-z]+_[wv]\\d\\d\\d.*\",\n            r\"^prd(_\\d\\d\\d)_([a-z]+)_[wv]\\d\\d\\d.*\",\n            r\"^prd(_\\d\\d\\d){2}_([a-z]+)_[wv]\\d\\d\\d.*\",\n            r\"^prd(_\\d\\d\\d){3}_([a-z]+)_[wv]\\d\\d\\d.*\",\n            r\"^prd(_\\d\\d\\d){3}(_[a-z]+){1,3}_[wv]\\d\\d\\d.*\",\n        ]\n        # Regular expression to validate BDL (Bill of Data List) filenames.\n        self.bdlregex = r\"prd_(\\d\\d\\d_|[a-zA-Z]{2}_([a-zA-Z09]*._){2})bd[lw]_[vw]\\d\\d\\d\\.xlsx\"\n        # Base path for asset work directories.\n        self._asset_folder = fspath(self.local_root) + \"/PROD/assets/work\"\n        # Regex to help an asset browser find asset work folders. \n        self._asset_folder_regex = fspath(self.local_root) + \"/PROD/assets/work/*/*/*\"\n\n        # Provides default template files. Used by return_next_version_name.\n        self._dict_file_templates = {\n            \"bdl\": Path(self.TEMPLATES_FOLDER, \"prd_template_bdl.xlsx\"),\n            \"bdw\": Path(self.TEMPLATES_FOLDER, \"prd_template_bdl.xlsx\"),\n            \"skt\": Path(self.TEMPLATES_FOLDER, \"prd_template_psd.psd\"),\n        }\n</code></pre> <p>Hard-Coded vs. Environment Variables</p> <p>While you can hard-code paths, using environment variables via self.env_handler is generally more flexible and maintainable, especially in larger studios or when managing multiple projects.</p>"},{"location":"dev/task_schema/examples/#34-dcc-config","title":"3.4 DCC Config","text":"<p>This section allows you to specify paths to custom tools, scripts, or shelves for Digital Content Creation (DCC) applications like Maya or Nuke. These paths are often used later (e.g., in <code>generate_environment_for_app()</code>) to set up the environment before launching a DCC.</p> <pre><code>        ...\n        ##############\n        # DCC Config #\n        ##############\n\n        # Paths to shared custom scripts, plugins, or shelves for DCC applications.  \n        # These are often added to environment variables in generate_environment_for_app().  \n        self.CUSTOM_MAYA_TOOLS = Path(self.server_root, \"pipeline/publish/dev/maya\")\n        self.CUSTOM_NUKE_TOOLS = Path(self.server_root, \"pipeline/publish/dev/nuke\")\n\n        ...\n</code></pre>"},{"location":"dev/task_schema/examples/#35-project-configuration","title":"3.5 Project Configuration","text":"<p>This section holds project-wide settings.</p> <ul> <li><code>_fps</code> / <code>_starting_frame</code>: Defines basic project standards like frames per second and the default starting frame number for new scenes.</li> <li><code>_dict_previous_tasks</code>: A vital mapping that defines task dependencies. It tells GwaIO, for a given task (e.g., 'uvs'), which task and step (e.g., 'model' from 'ModelingStep') typically come before it. This is used to easily find upstream published files.</li> </ul> <pre><code>        ...\n\n        ##################\n        # Project Config #\n        ##################\n\n        self._fps = 25 # Frames per second for the project.  \n        self._starting_frame = 101 # Default start frame for animation, playblasts, etc.\n        # --- Previous Task Mapping ---  \n        # Defines dependencies: maps a current task name to its typical upstream task.  \n        # Used to find outputs from previous steps (e.g., model from blocking for rigging).  \n        # Key: current task's long SG name. Value: dict {task_name: prev_task_long_SG_name, step: prev_task_SG_Step_code}.  \n        self._dict_previous_tasks = {\n            \"line\": {\"task\": \"sketch\", \"step\": \"ConceptArtStep\"},\n            \"color\": {\"task\": \"line\", \"step\": \"ConceptArtStep\"},\n            \"model\": {\"task\": \"blocking\", \"step\": \"ModelingStep\"},\n            \"uvs\": {\"task\": \"model\", \"step\": \"ModelingStep\"},\n        }\n        ...\n</code></pre>"},{"location":"dev/task_schema/examples/#36-edl-configuration","title":"3.6 EDL Configuration","text":"<p>If your workflow involves processing Edit Decision Lists (EDLs), these variables configure how GwaIO should parse them, identify shots/sequences/episodes, and interact with ShotGrid during EDL-based operations.</p> <pre><code>        ...\n\n        ##############\n        # EDL Config #\n        ##############\n\n        self._edl_target_task = \"animatic\" # Default SG Task name for EDL processing\n        self._edl_task_name = \"EDL\"\n        self._edl_shot_prefix = \"\"\n        self._edl_sequence_prefix = \"\"\n        self._edl_episode_prefix = \"plt_\"\n        self.edl_sequence_regex = compile(r\"(?&lt;=plt_)\\d{3}_\\d{3}\")\n        self._edl_shot_regex = compile(r\"(?&lt;=plt_)\\d{3}_\\d{3}_\\d{3}\")\n        self.edl_version_regex = compile(r\"(?&lt;=_[VvWw])\\d\\d\\d\")\n        self._shot_task_tpl_id = 1069\n        self._episode_edl_workflow = True\n        self._edl_episode_regex = compile(r\"plt_\\d{3}\")\n\n        ...\n</code></pre>"},{"location":"dev/task_schema/examples/#37-publisher-configuration","title":"3.7 Publisher Configuration","text":"<p>This section configures the GwaIO Publisher tool.</p> <ul> <li><code>publisher_builder_data</code>: This dictionary is key. It maps task names (e.g., 'line', 'model') to a set of <code>Collect</code> and <code>Push</code> classes. When a user opens the Publisher on a specific task, GwaIO uses this map to build the UI, showing the relevant collection (gathering data) and push (publishing data) steps for that task. </li> </ul> <p>Tip</p> <p>To learn how to create custom <code>Collect</code> and <code>Push</code> classes, refer to the GwaIO Publisher framework documentation.</p> <pre><code>        ...\n\n        ####################\n        # Publisher Config #\n        ####################\n\n        # Configures the publisher UI by mapping task types to Collect and Push classes.\n        self.publisher_builder_data = {\n            \"line\": {\n                CollectTask,\n                CollectFileConcept,\n                CollectPreview,\n                CollectBID,\n                CollectDescription,\n                PushSG,\n            },\n            \"color\": {\n                CollectTask,\n                CollectFileConcept,\n                CollectPreview,\n                CollectBID,\n                CollectDescription,\n                PushSG,\n            },\n            \"sbRough\": {\n                CollectTask,\n                CollectFileVideo,\n                CollectPreviewVideo,\n                CollectBID,\n                PushSG,\n            },\n            \"model\": {\n                CollectTask,\n                CollectFileVideo,\n                CollectPreviewVideo,\n                CollectBID,\n                PushSG,\n            },\n        }\n\n        ...\n</code></pre>"},{"location":"dev/task_schema/examples/#4-override-file-system-layout","title":"4. Override File-System Layout","text":"<p>Implement <code>get_task_filesystem</code> to map entities to your folder structure. In this case, we will add a pipeline that differentiates between <code>work</code> and <code>publish</code> files.</p> <pre><code>    def get_task_filesystem(\n        self, code, entity_type, task, step, asset_type, state=\"work\", *args, **kwargs\n    ):\n        slug: str = None\n        if entity_type == \"Asset\":\n            slug = Path(\n                \"production\", state, \"assets\", asset_type, *code.split(\"_\"), task\n            )\n        elif entity_type == \"Episode\":\n            slug = Path(f\"production/{state}/episodes\", code, task)\n        elif entity_type == \"Shot\":\n            slug = Path(\"production\", state, \"shots\", *code.split(\"_\")[0:3], task)\n        if slug is None:\n            return None, None\n\n        return self._local_root / slug, self._server_root / slug\n</code></pre> <p>Warning</p> <p>Ensure <code>code</code> formatting matches ShotGrid conventions.</p>"},{"location":"dev/task_schema/examples/#5-versioning-and-naming-return_next_version_name","title":"5. Versioning and Naming: return_next_version_name()","text":"<p>This method dictates how new work files are named, particularly the version number. It's called when the user initiates a \"Create File\" or \"Save Next Version\" action from the launcher UI.</p> <p>Attributes used:</p> <ul> <li>self.last_task_clicked: The currently selected BaseTask object in the UI, providing context.  </li> <li>self.task_long_to_short_dict (from ShotgridPlugin): To get short task names if used in filenames.  </li> <li>self.return_last_file() (from BasePlugin): To find the previous version number and file.  </li> <li>self.version_regex: To parse version numbers from existing files.  </li> <li>self._dict_file_templates: To find a suitable template if no previous version exists.  </li> <li>self.TEMPLATES_FOLDER: Fallback directory for templates.  </li> <li>task.entity_type, task.link_name, task.asset_type, task.local_path: Attributes from the BaseTask object.</li> </ul> <pre><code>    def return_next_version_name(self, ext: Iterable, version: int = None) -&gt; dict:\n        # ext: A list of possible file extensions (e.g., [\".ma\"], [\".spp\"]).  \n        #      The first extension in the list is typically used for the new file.  \n        # version: Optional integer to force a specific version number (rarely used by typical UI calls).  \n        task = self.last_task_clicked\n        if task is not None:\n            task_name = self.task_long_to_short(task.name)\n            link = task.link_name\n            type_ = task.asset_type\n            v, last_file = self.return_last_file(ext, task=task)\n            v = version or v\n            match task.entity_type:\n                case \"Asset\":\n                    file_name = f\"plt_{type_}_{link}_{task_name}_w{v+1:03}\"\n                case \"Shot\":\n                    file_name = f\"plt_{link}_{task_name}_w{v+1:03}\"\n                case \"Episode\":\n                    file_name = f\"plt_{link}_{task_name}_w{v+1:03}\"\n            if last_file is None:\n                last_file = self._dict_file_templates.get(task_name)\n                if not last_file:\n                    last_file = Path(self.TEMPLATES_FOLDER)\n\n            return {\n                \"local_path\": Path(task.local_path),\n                \"file_name\": file_name,\n                \"previous_file\": last_file,\n                \"full_file_name\": Path(task.local_path, f\"{file_name}.{ext[0]}\"),\n            }\n</code></pre> <p>As demonstrated in this method, it performs a check to determine the file's type and subsequently generates the next version number. If no previous version of the file exists, the method defaults to providing a suitable template file from <code>_dict_file_templates</code> or, if no specific template is found, the path to the <code>TEMPLATES_FOLDER</code>. This mechanism ensures a consistent and controlled naming convention for all new files.</p>"},{"location":"dev/task_schema/examples/#6-publishing-workflow","title":"6. Publishing Workflow","text":""},{"location":"dev/task_schema/examples/#61-helper-methods-for-publish-paths","title":"6.1. Helper Methods for Publish Paths","text":"<p>Attributes used by work_to_publish:</p> <p>This method generates the local and server-side publish paths for a given work task.</p> <ul> <li>self.last_task_clicked: The currently selected BaseTask object in the UI, providing context. </li> <li>task.server_path task.local_path: Attributes from the BaseTask object.</li> </ul> <pre><code>    def work_to_publish(self, task: BaseTask = None) -&gt; Path:\n        task = task or self.last_task_clicked\n        if task is None:\n            return None, None\n        publish_local_path = Path(\n            *[p if p != \"work\" else \"publish\" for p in task.local_path.parts]\n        )\n        publish_server_path = Path(\n            *[p if p != \"work\" else \"publish\" for p in task.server_path.parts]\n        )\n        return publish_local_path, publish_server_path\n</code></pre> <p>This method computes the next publish filename (with version increment) and returns both the local and server paths for that file.</p> <p>Attributes used by return_next_publish_file:</p> <ul> <li>self.work_to_publish_paths(): To get the base publish directories.  </li> <li>self.version_regex (implicitly, for parsing existing publish versions, though the example uses a specific regex r\"(?\\&lt;=_v)\\d{3}\" for publish files).  </li> <li>task.entity_type, task.link_name, task.asset_type, task.name: For constructing the publish filename.  </li> <li>self.task_long_to_short_dict: For short task names in filenames.</li> </ul> <pre><code>    def return_next_publish_file(self, work_file: Path, task: BaseTask = None):\n        task = task or self.last_task_clicked\n        if task is None:\n            return None, None\n        publish_local_path, publish_server_path = self.work_to_publish(task)\n        v = self.return_last_version_number(publish_server_path)\n        task_name = self.task_long_to_short(task.name)\n        link = task.link_name\n        type_ = task.asset_type\n        ext = work_file.suffix\n        match task.entity_type:\n            case \"Asset\":\n                file_name = f\"plt_{type_}_{link}_{task_name}_v{v+1:03}\"\n            case \"Shot\":\n                file_name = f\"plt_{link}_{task_name}_v{v+1:03}\"\n            case \"Episode\":\n                file_name = f\"plt_{link}_{task_name}_v{v+1:03}\"\n\n        return Path(publish_local_path, f\"{file_name}{ext}\"), Path(\n            publish_server_path, f\"{file_name}{ext}\"\n        )\n</code></pre> <ul> <li>is_published_file: Prevent duplicates.  </li> <li>return_seq_and_shot_from_clipname: Parse shot/sequence.  </li> <li>ShotGrid Utilities: <code>return_task_notes</code>, <code>create_note</code>, <code>browse_*</code>, <code>task_long_to_short</code>, <code>retrieve_cached</code>, etc.</li> </ul>"},{"location":"dev/task_schema/examples/#62-publish-version-publish_version","title":"6.2 Publish version publish_version()","text":"<p>This is the main method called by the publisher UI (e.g., via a PushSG class) or other publish triggers. It orchestrates file copying and ShotGrid entity creation. To learn how to implement custom publisher classes, please refer to the framework documentation at Publisher.  </p> <p>Attributes used:</p> <ul> <li>self.server_root: To check server connectivity.  </li> <li>self.local_root</li> <li>self.return_next_publish_file(): To determine target publish paths.  </li> <li>super().publish_version(): Calls the ShotgridPlugin's method to create the SG Version and upload the preview.  </li> <li>self.publish_file() (from ShotgridPlugin): To create SG PublishedFile entities.  </li> <li>task: Instance from the BaseTask object.  </li> </ul> <pre><code>    def publish_version(\n        self,\n        task: BaseTask,\n        preview: Path = None,\n        file: Path = None,\n        description: str = \"\",\n    ) -&gt; bool:\n        try:\n            if not Path(self._server_root).exists():\n                return {\n                    \"success\": False,\n                    \"message\": \"Not connected to the server.\",\n                    \"error\": \"Not connected to the server.\",\n                    \"entity\": None,\n                }\n            if isinstance(task, dict):\n                task = BaseTask(**task)\n            if file is None:\n                file = preview\n            work_server_file = Path(\n                self._server_root,\n                *Path(file).parts[len(Path(self._local_root).parts) :],\n            )\n            work_server_preview = Path(\n                self._server_root,\n                *Path(preview).parts[len(Path(self._local_root).parts) :],\n            )\n            publish_local_file, publish_server_file = self.return_next_publish_file(\n                Path(file)\n            )\n            publish_local_preview = Path(\n                publish_local_file.parent,\n                publish_local_file.stem + Path(preview).suffix,\n            )\n            publish_server_preview = Path(\n                publish_server_file.parent,\n                publish_server_file.stem + Path(preview).suffix,\n            )\n            if not publish_local_file or not publish_server_file:\n                return {\n                    \"success\": False,\n                    \"message\": \"The file could not be published on the server. Check that you have selected a correct file.\",\n                    \"error\": \"The file could not be published on the server. Check that you have selected a correct file.\",\n                    \"entity\": None,\n                }\n\n            work_server_file.parent.mkdir(exist_ok=True, parents=True)\n            publish_local_file.parent.mkdir(exist_ok=True, parents=True)\n            publish_server_file.parent.mkdir(exist_ok=True, parents=True)\n\n            if file == preview:\n                local_to_server = [\n                    [file, work_server_file],\n                    [file, publish_local_file],\n                    [work_server_file, publish_server_file],\n                ]\n            else:\n                local_to_server = [\n                    [file, work_server_file],\n                    [preview, work_server_preview],\n                    [file, publish_local_file],\n                    [preview, publish_local_preview],\n                    [work_server_file, publish_server_file],\n                    [work_server_preview, publish_server_preview],\n                ]\n            for src, dst in local_to_server:\n                if src == dst:\n                    continue\n                copy2(src, dst)\n            for src, dst in local_to_server:\n                if not Path(dst).exists():\n                    raise Exception(f\"The file could not be copied to {dst}\")\n        except Exception as e:\n            traceback.print_exc()\n            for src, dst in local_to_server:\n                if src != dst and Path(dst).exists():\n                    remove(dst)\n            return {\n                \"success\": False,\n                \"message\": f\"{str(e)}\",\n                \"error\": \"Upload failed\",\n                \"entity\": None,\n            }\n        try:\n            result = super().publish_version(task, publish_server_preview, description)\n        except Exception as e:\n            traceback.print_exc()\n            result = {\n                \"success\": False,\n                \"message\": f\"{str(e)}\",\n                \"error\": \"Upload failed\",\n                \"entity\": None,\n            }\n        if not result.get(\"success\"):\n            for src, dst in local_to_server:\n                if src != dst and Path(dst).exists():\n                    remove(dst)\n        else:\n            self.publish_file(publish_server_file, result[\"entity\"], task, description)\n\n        return result\n</code></pre> <p>As we can see, a series of steps is followed to ensure a correct publication. This involves:</p> <ol> <li>Validating inputs and server connection. </li> <li>Determining paths for working files and published files (local and server).  </li> <li>Copying files to their respective locations in the correct order.  </li> <li>If file copies are successful, publishing a version to ShotGrid (or a similar system).  </li> <li>If the ShotGrid publish is successful, linking the main published file.  </li> <li>Rollback (cleanup of copied files) occurs if any critical step fails.</li> </ol> <p>Warning</p> <p>The <code>publish_version</code> method is complex and critical. It involves multiple file operations and API calls. Implement comprehensive error handling, clear logging, and consider transactional behavior (i.e., if one step fails, attempt to roll back previous steps to avoid leaving the system in an inconsistent state). The example includes basic rollback for file copies if ShotGrid operations fail.</p>"},{"location":"dev/task_schema/examples/#7-asset-creation-from-bdl-create_assets_from_bdl","title":"7. Asset Creation from BDL: <code>create_assets_from_bdl</code>","text":""},{"location":"dev/task_schema/examples/#71-create_assets_from_bdl","title":"7.1. create_assets_from_bdl","text":"<p>This method processes validated asset entries from a BDL Excel file and publishes them to ShotGrid, including:</p> <ul> <li>Ensuring the Episode exists.</li> <li>Hashing and publishing the BDL file if it's new.</li> <li>Creating or updating Asset entities, including parent links and metadata.</li> </ul> <p>Attributes and Helpers Used:</p> <ul> <li> <p><code>self.return_all_assets()</code> : Dictionary of existing SG assets to detect duplicates.</p> </li> <li> <p><code>self.return_all_episodes()</code> : Dictionary of existing SG episodes for contextual association.</p> </li> <li> <p><code>hash_file(excel_file)</code> :Returns <code>(md5, sha1)</code> to check for already published BDLs.</p> </li> <li> <p><code>self.sg.create(entity_type, data_dict)</code>  :ShotGrid API helper for creating entities like Assets or Episodes.</p> </li> <li> <p><code>self.sg.update(entity_type, id, data_dict, multi_entity_update_modes)</code> : Used to update fields like episodes or parent assemblies.</p> </li> <li> <p><code>self.publish_version(pseudo_task, src_file, pub_file, description)</code>: Publishes the BDL Excel to ShotGrid as a Version.</p> </li> <li> <p><code>self.SG_PROJECT_ID</code>: The active ShotGrid project ID.</p> </li> </ul> <pre><code>    def create_assets_bdl(self, dict_with_items: dict, excel_file: Path):\n        logger.debug(\"Starting asset generation phase.\")\n        logger.debug(\"Collecting SG data.\")\n        created_assets = self.return_all_assets()\n        created_episodes = self.return_all_episodes()\n        project = {\"type\": \"Project\", \"id\": int(self.SG_PROJECT_ID)}\n        episode = f\"{excel_file.name.split('_')[1]}\"\n\n        if episode not in created_episodes:\n            logger.debug(f\"Episode not exists. Generating episode {episode}\")\n            ep_task_template = self.sg.find_one(\n                \"TaskTemplate\", [[\"code\", \"is\", f\"gwaio_episode\"]]\n            )\n            ep = self.sg.create(\n                \"Episode\",\n                {\n                    \"code\": episode,\n                    \"project\": project,\n                    \"task_template\": ep_task_template,\n                },\n            )\n            created_episodes.update({episode: ep})\n        else:\n            ep = created_episodes[episode]\n            logger.debug(f\"Episode {episode} found\")\n\n        md5hash, sha1hash = hash_file(excel_file)\n        description = f\"Hashes: \\nmd5: '{md5hash}'\\nsha1: '{sha1hash}'\"\n\n        match_version = self.sg.find_one(\n            \"Version\",\n            [[\"description\", \"is\", description]],\n        )\n        if not match_version:\n            logger.debug(f\"Starting generation of BDL version in SG. Episode {episode}\")\n            logger.debug(\"Hashing BDL file.\")\n            sg_task = self.sg.find_one(\n                \"Task\", [[\"entity\", \"is\", ep], [\"content\", \"is\", \"bdl\"]]\n            )\n            logger.debug(f\"BDL task found {sg_task}\")\n\n            class PseudoBaseTask:\n                entity = ep\n                task_entity = sg_task\n\n            result = self.publish_version(\n                PseudoBaseTask, excel_file, excel_file, description\n            )\n            if not result.get(\"success\"):\n                raise Exception(\n                    f\"Error while publishing BDL file.\\n{result.get('message')}\"\n                )\n            logger.debug(f\"Published BDL version in SG episode {episode}.\")\n\n        for key, value in dict_with_items.items():\n            logger.debug(f\"Working on item {value}\")\n            if not value[\"status\"]:\n                logger.debug(f\"Error on item {value}. Fix it\")\n                yield True\n                continue\n            tags = (\n                [value[\"series\"][5]]\n                if \",\" not in value[\"series\"][5]\n                else value[\"series\"][5].split(\",\")\n            )\n            parents = (\n                [value[\"series\"][3]]\n                if \",\" not in value[\"series\"][3]\n                else value[\"series\"][3].split(\",\")\n            )\n\n            if value[\"asset_name\"] not in created_assets:\n                task_template = self.sg.find_one(\n                    \"TaskTemplate\",\n                    [[\"code\", \"is\", f\"gwaio_asset_{value['series'][0]}\"]],\n                )\n                logger.debug(f\"Task template found {task_template}.\")\n                data = {\n                    \"code\": value[\"asset_name\"],\n                    \"project\": project,\n                    \"episodes\": [ep],\n                    \"sg_created_for_episode\": ep,\n                    \"sg_asset_type\": value[\"series\"][0],\n                    \"task_template\": task_template,\n                    \"description\": value[\"series\"][4],\n                    # \"tags\": tags,\n                }\n                logger.debug(data)\n                created_asset = self.sg.create(\"Asset\", data)\n                logger.debug(f\"Asset {value['asset_name']} was created.\")\n            else:\n                created_asset = created_assets[value[\"asset_name\"]]\n\n            self.sg.update(\n                \"Asset\",\n                created_asset[\"id\"],\n                {\n                    \"episodes\": [ep],\n                    \"description\": value[\"series\"][4],\n                    \"sg_parent_assemblies\": [\n                        v for k, v in created_assets.items() if k in parents\n                    ],\n                },\n                multi_entity_update_modes={\n                    \"episodes\": \"add\",\n                    \"sg_parent_assemblies\": \"add\",\n                },\n            )\n            created_assets[value[\"asset_name\"]] = created_asset\n\n            yield created_asset\n</code></pre> <p>!!! tip \ud83d\udca1 Use consistent naming conventions for Excel files, e.g. <code>bdl_EP01.xlsx</code>, so episode codes are always found correctly.</p> <p>Tip</p> <p>If the BDL file is already registered in ShotGrid (matched by file hash), it will not be re-published.</p>"},{"location":"dev/task_schema/examples/#72-create_assets_bdw","title":"7.2. create_assets_bdw","text":"<p>This method processes asset entries from a BDW Excel file and publishes them as Asset entities in ShotGrid, using the currently selected task (<code>self.last_task_clicked</code>) as context.</p> <p>Attributes and Helpers Used:</p> <ul> <li> <p><code>self.return_all_assets()</code>: Retrieves a dictionary of currently registered SG assets.</p> </li> <li> <p><code>hash_file(excel_file)</code>: Computes the <code>md5</code> and <code>sha1</code> of the BDW file for identifying previously published files.</p> </li> <li> <p><code>self.publish_version(task, src, pub, description)</code>: Publishes the BDW file to ShotGrid if it hasn't been published before (hash-based).</p> </li> <li> <p><code>self.sg.find_one(entity, filters)</code>: ShotGrid API call to find matching Version/Template data.</p> </li> <li> <p><code>self.sg.create(entity_type, data_dict)</code>: Creates a new Asset entity in SG if it doesn't exist.</p> </li> <li> <p><code>self.sg.update(entity_type, id, data_dict, multi_entity_update_modes)</code>: Updates asset metadata and relationships like parent assemblies.</p> </li> <li> <p><code>self.SG_PROJECT_ID</code>: Current ShotGrid project ID.</p> </li> </ul> <pre><code>    def create_assets_bdw(self, dict_with_items: dict, excel_file: Path):\n        created_assets = self.return_all_assets()\n        project = {\"type\": \"Project\", \"id\": int(self.SG_PROJECT_ID)}\n        task = self.last_task_clicked\n        md5hash, sha1hash = hash_file(excel_file)\n        description = f\"Hashes: \\nmd5: '{md5hash}'\\nsha1: '{sha1hash}'\"\n\n        match_version = self.sg.find_one(\n            \"Version\",\n            [[\"description\", \"is\", description]],\n        )\n        if not match_version:\n            result = self.publish_version(task, excel_file, excel_file, description)\n            if not result.get(\"success\"):\n                raise Exception(\n                    f\"Error while publishing BDW file.\\n{result.get('message')}\"\n                )\n\n        for key, value in dict_with_items.items():\n            if not value[\"status\"]:\n                yield True\n                continue\n            tags = (\n                [value[\"series\"][5]]\n                if \",\" not in value[\"series\"][5]\n                else value[\"series\"][5].split(\",\")\n            )\n            parents = (\n                [value[\"series\"][3]]\n                if \",\" not in value[\"series\"][3]\n                else value[\"series\"][3].split(\",\")\n            )\n\n            if value[\"asset_name\"] not in created_assets:\n                task_template = self.sg.find_one(\n                    \"TaskTemplate\",\n                    [[\"code\", \"is\", f\"gwaio_asset_{value['series'][0]}\"]],\n                )\n                data = {\n                    \"code\": value[\"asset_name\"],\n                    \"project\": project,\n                    \"sg_asset_type\": value[\"series\"][0],\n                    \"task_template\": task_template,\n                    \"description\": value[\"series\"][4],\n                    # \"tags\": tags,\n                }\n                created_asset = self.sg.create(\"Asset\", data)\n            else:\n                created_asset = created_assets[value[\"asset_name\"]]\n\n            self.sg.update(\n                \"Asset\",\n                created_asset[\"id\"],\n                {\n                    \"description\": value[\"series\"][4],\n                    \"sg_parent_assemblies\": [\n                        v for k, v in created_assets.items() if k in parents\n                    ],\n                },\n                multi_entity_update_modes={\n                    \"episodes\": \"add\",\n                    \"sg_parent_assemblies\": \"add\",\n                },\n            )\n            created_assets[value[\"asset_name\"]] = created_asset\n\n            yield created_asset\n</code></pre> <p>!!! tip \ud83d\udca1: Use unique BDW content or filenames per iteration to avoid duplicate hash rejections in ShotGrid.  </p> <p>!!! note \u26a0\ufe0f: Unlike <code>create_assets_bdl</code>, this method does not associate assets with any Episode. It's typically used for sequences or work files not tied to a specific episode.</p>"},{"location":"dev/task_schema/examples/#73-create_assets_from_bdl","title":"7.3. create_assets_from_bdl","text":"<p>This method reads a BDL Excel file, validates its rows, and creates new Asset entities in ShotGrid for each entry marked as active.</p> <p>Attributes and Helpers Used: - <code>self.read_excel(file_path)</code> \u2192 <code>(headers, data)</code>   Parses the Excel/BDL file and returns both the raw headers and a dictionary of validated row data. - <code>self.sg.create(entity_type, data_dict)</code>   ShotGrid API helper for creating a new entity.</p> <pre><code>    def create_assets_from_bdl(self, dict_with_items: dict, excel_file: Path):\n        if self.last_task_clicked.name == \"episode\":\n            for asset in self.create_assets_bdl(dict_with_items, excel_file):\n                yield asset\n        else:\n            for asset in self.create_assets_bdw(dict_with_items, excel_file):\n                yield asset\n</code></pre>"},{"location":"dev/task_schema/examples/#8-reading-excelbdl-files-read_excel","title":"8. Reading Excel/BDL Files: read_excel()","text":"<p>This method parses an Excel-based BDL file and validates its contents against production rules and existing ShotGrid data. It uses the <code>pandas</code> library for robust Excel handling and ensures data integrity before downstream processing.</p> <p>Attributes used:</p> <pre><code>    def read_excel(self, excel: Path):\n        existing_assets = self.return_all_assets()\n        data_frame = (\n            pandas.read_excel(excel, usecols=[0, 1, 2, 3, 4, 5])\n        )\n        data_frame.fillna(\"\", inplace=True)\n        dupes = data_frame.duplicated(\n            subset=data_frame.columns[1:3].tolist(), keep=False\n        )\n\n        results = dict()\n        for i, row in data_frame.iterrows():\n            asset_type, code, variant, parent_assets = row[:4]\n            asset_name = f\"{code}_{variant}\"\n\n            results[i] = {\n                \"series\": [content for content in row[:6].tolist()],\n                \"errors\": list(),\n                \"warnings\": list(),\n                \"episode\": f\"{excel.name.split(\"_\")[1]}\",\n                \"asset_name\": asset_name,\n                \"exists\": asset_name in existing_assets,\n                \"status\": True,\n            }\n\n            if dupes[i]:\n                results[i][\"errors\"].append(\"This asset is repeated.\")\n\n            if asset_type not in [\"ch\", \"pr\", \"ve\", \"sp\", \"mp\", \"fx\", \"en\"]:\n                results[i][\"errors\"].append(f\"Unknown asset type '{asset_type}'\")\n\n            if parent_assets:\n                if not \",\" in parent_assets:\n                    parent_assets = [parent_assets]\n                else:\n                    parent_assets = parent_assets.split(\",\")\n\n                for parent_asset in parent_assets:\n                    if parent_asset not in existing_assets:\n                        candidate = next(\n                            (\n                                k\n                                for k in existing_assets\n                                if smatch(None, k, parent_asset).ratio() &gt; 0.8\n                            ),\n                            None,\n                        )\n                        results[i][\"errors\"].append(\n                            f\"Parent asset {parent_asset} \"\n                            + \"does not exist in SG, please create it first. \"\n                            + (\"\\n\" if candidate else \"\")\n                            + f\"{('Maybe you meant '+ candidate + '?') if candidate is not None else ''}\"\n                        )\n\n            if asset_name in existing_assets:\n                results[i][\"exists\"] = True\n                results[i][\"warnings\"].append(f\"Asset already exists\")\n\n            for content in [*row[:2]]:\n                if content in (None, \"\"):\n                    results[i][\"errors\"].append(\"There are some empty fields.\")\n\n            for tag in (code, variant):\n                if not tag.replace(\"_\", \"\").isalnum() and tag != \"\":\n                    results[i][\"errors\"].append(\n                        f\"There are non alphanumeric values: \"\n                        f\"{sub('[^0-9a-zA-Z]+', '*', tag)}\"\n                    )\n\n            results[i][\"status\"] = len(results[i][\"errors\"]) == 0\n\n        return [*data_frame.columns[:6].tolist()], results\n</code></pre> <p>Warning</p> <p>This method is provided as a project-specific example. It is highly customizable and should only be used in projects where the Excel parsing and asset creation pipeline matches this implementation exactly.</p>"},{"location":"dev/task_schema/examples/#9-parsing-edls-and-creating-shots","title":"9. Parsing EDLs and Creating Shots","text":"<p>If your workflow involves EDLs (Edit Decision Lists) for creating or updating ShotGrid shots,  you will need methods such as <code>parse_edl_file()</code> and <code>create_shot()</code>.  These methods are highly specific to the structure of your EDL files (XML, CSV, standard CMX EDL, etc.)  and how that information maps to ShotGrid fields (e.g., cut-in, cut-out, sequence/episode linking, etc.).</p> <p>In most cases, implementing <code>return_seq_and_shot_from_clipname()</code>  along with the required supporting variables should be sufficient for parsing the EDL and generating valid shot names.</p> <pre><code>    def return_seq_and_shot_from_clipname(self, clip_name: str) -&gt; str:\n        _,ep,sq,sh = clip_name.split(\"_\")\n        return f\"{ep}_{sq}\", f\"{ep}_{sq}_{sh}\"\n</code></pre> <p>Tip</p> <p>This assumes your clip names follow a strict naming convention like <code>plt_EP001_SQ002_SH010</code>. Adapt the parsing logic if your naming scheme differs.</p> <p>Warning</p> <p>The default implementation of <code>parse_edl_file()</code> is minimal and meant for basic pipelines. If your EDL structure is more complex or requires additional validation/mapping logic, you should override <code>parse_edl_file()</code> with a custom implementation tailored to your needs.</p>"},{"location":"dev/task_schema/examples/#10-custom-callbacks-and-hooks","title":"10. Custom Callbacks and Hooks","text":"<p>Plugins can implement callback methods that are triggered by certain events within the launcher application.</p> <ul> <li>file_added_callback(): This method is invoked automatically after a file has been successfully created or associated with a task through the launcher's UI (e.g., via the \"Create File\" dialog or by dragging and dropping a file onto a task). It's a useful hook for automating subsequent actions, such as updating the status of the corresponding task in ShotGrid.</li> </ul> <pre><code>def file_added_callback(self) -&gt; None:\n        if (\n            self.sg.find_one(\n                \"Task\",\n                [[\"id\", \"is\", self.last_task_clicked.task_entity.get(\"id\")]],\n                [\"sg_status_list\"],\n            ).get(\"sg_status_list\")\n            == \"rdy\"\n        ):\n            self.sg.update(\n                \"Task\",\n                self.last_task_clicked.task_entity.get(\"id\"),\n                {\"sg_status_list\": \"ip\"},\n            )\n</code></pre>"},{"location":"dev/task_schema/modules/","title":"Modules","text":""},{"location":"dev/task_schema/modules/#indice-de-modulos","title":"\u00cdndice de M\u00f3dulos","text":"<p>Este archivo se genera autom\u00e1ticamente. No editar.</p>"},{"location":"dev/task_schema/modules/#modulos","title":"M\u00f3dulos","text":"<ul> <li>examples.example_plugin</li> <li>plugins.aisha_test_plugin</li> <li>plugins.anniecarola_plugin</li> <li>plugins.anniecarolanew_plugin</li> <li>plugins.base_plugin</li> <li>plugins.blender_test_plugin</li> <li>plugins.furrytails_plugin</li> <li>plugins.furrytailsnew_plugin</li> <li>plugins.generic2d_plugin</li> <li>plugins.google_plugin</li> <li>plugins.grisu_plugin</li> <li>plugins.gwaio_plugin</li> <li>plugins.letrabots_plugin</li> <li>plugins.maya_unreal_test_plugin</li> <li>plugins.meteoheroes_plugin</li> <li>plugins.miniraja_plugin</li> <li>plugins.nivis_plugin</li> <li>plugins.piloto_plugin</li> <li>plugins.shotgrid_plugin</li> <li>tests.test_anniecarola_plugin</li> <li>tests.test_anniecarolanew_plugin</li> <li>tests.test_base_plugin</li> <li>tests.test_google_plugin</li> <li>tests.test_grisu_plugin</li> <li>tests.test_shotgrid_plugin</li> </ul>"},{"location":"dev/task_schema/examples/example_plugin/","title":"example_plugin","text":""},{"location":"dev/task_schema/examples/example_plugin/#example_plugin","title":"<code>example_plugin</code>","text":""},{"location":"dev/task_schema/plugins/aisha_test_plugin/","title":"aisha_test_plugin","text":""},{"location":"dev/task_schema/plugins/aisha_test_plugin/#aisha_test_plugin","title":"<code>aisha_test_plugin</code>","text":""},{"location":"dev/task_schema/plugins/aisha_test_plugin/#plugins.aisha_test_plugin","title":"aisha_test_plugin","text":""},{"location":"dev/task_schema/plugins/anniecarola_plugin/","title":"anniecarola_plugin","text":""},{"location":"dev/task_schema/plugins/anniecarola_plugin/#anniecarola_plugin","title":"<code>anniecarola_plugin</code>","text":""},{"location":"dev/task_schema/plugins/anniecarola_plugin/#plugins.anniecarola_plugin","title":"anniecarola_plugin","text":"<p>Classes:</p> <ul> <li> <code>AnnieCarolaPlugin</code>           \u2013            </li> </ul>"},{"location":"dev/task_schema/plugins/anniecarola_plugin/#plugins.anniecarola_plugin.AnnieCarolaPlugin","title":"AnnieCarolaPlugin","text":"<pre><code>AnnieCarolaPlugin(*args, **kwargs)\n</code></pre> <p>Methods:</p> <ul> <li> <code>parse_clip_name</code>             \u2013              <p>AC_EP102_ATIC_V01-110-110_010</p> </li> </ul>"},{"location":"dev/task_schema/plugins/anniecarola_plugin/#plugins.anniecarola_plugin.AnnieCarolaPlugin.parse_clip_name","title":"parse_clip_name","text":"<pre><code>parse_clip_name(clip_name: str)\n</code></pre> <p>AC_EP102_ATIC_V01-110-110_010</p>"},{"location":"dev/task_schema/plugins/anniecarolanew_plugin/","title":"anniecarolanew_plugin","text":""},{"location":"dev/task_schema/plugins/anniecarolanew_plugin/#anniecarolanew_plugin","title":"<code>anniecarolanew_plugin</code>","text":""},{"location":"dev/task_schema/plugins/anniecarolanew_plugin/#plugins.anniecarolanew_plugin","title":"anniecarolanew_plugin","text":""},{"location":"dev/task_schema/plugins/base_plugin/","title":"base_plugin","text":""},{"location":"dev/task_schema/plugins/base_plugin/#base_plugin","title":"<code>base_plugin</code>","text":""},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin","title":"base_plugin","text":"<p>base_plugin.py</p> <p>This module provides the BasePlugin system for managing tasks, thumbnails, and plugin environment within the launcher application. It includes the BaseThumbnail, BaseTask, and BasePlugin classes</p> <p>Classes:</p> <ul> <li> <code>BasePlugin</code>           \u2013            <p>Core plugin class providing shared launcher functionality.</p> </li> <li> <code>BaseTask</code>           \u2013            <p>Represents a unit of work within a plugin, including paths and metadata.</p> </li> <li> <code>BaseThumbnail</code>           \u2013            <p>Represents a thumbnail resource for a task.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin","title":"BasePlugin","text":"<pre><code>BasePlugin(username: str = None, *args, **kwargs)\n</code></pre> <p>Core plugin class providing shared launcher functionality.</p> Class Attributes <p>TITLE (str): Display title of the plugin. PLUGIN_UUID (Optional[str]): Unique identifier. super_user (str): Username for elevated operations. env_handler (EnvironmentHandler): Environment manager for environment variables. TEMPLATES_FOLDER (Path): Path to templates folder. BDLS_PATH (Path): Path for BDLs files. SL_SERVER_PATH (Path): Path for session logs on server. GWAIO_DEADLINE_REPO_PATH (str): Path for Deadline repository. OCIO_FILE (Optional[Path]): Filepath for OCIO configuration. CUSTOM_MAYA_TOOLS (Optional[Path]): Path for custom Maya tools. CUSTOM_NUKE_TOOLS (Optional[Path]): Path for custom Nuke tools. CUSTOM_HOUDINI_TOOLS (Optional[Path]): Path for custom Houdini tools. GWAIO_MAYA_LIGHT_TEMPLATE (Path): Default Maya light rig template. title (str): Human-readable title of the plugin. uses_deadline (bool): Flag indicating Deadline integration. create_file_ext (List[str]): Default file extensions for creation. task_subfolders (Dict[str, List[str]]): Default subfolders for each task.</p> <p>Parameters:</p> <p>Methods:</p> <ul> <li> <code>__del__</code>             \u2013              <p>This method should be called before unmounting this plugin.</p> </li> <li> <code>after_publish</code>             \u2013              <p>Hook called after publishing process completes.</p> </li> <li> <code>browse_note_data</code>             \u2013              <p>This method should be overriden according to each plugin.</p> </li> <li> <code>browse_task_data</code>             \u2013              <p>This method should be overriden according to each plugin.</p> </li> <li> <code>browse_version_data</code>             \u2013              <p>This method should be overriden according to each plugin.</p> </li> <li> <code>check_version_is_published</code>             \u2013              <p>Determine whether a given version file has already been published.</p> </li> <li> <code>copy_edl_files_to_server</code>             \u2013              <p>Copy EDL-associated video and audio files to the server location.</p> </li> <li> <code>create_assets_from_bdl</code>             \u2013              <p>Receives an standarized dictionary that holds the data for creating assets.</p> </li> <li> <code>create_dir_if_missing</code>             \u2013              <p>Create a directory (and its defined subfolders) if it does not exist.</p> </li> <li> <code>create_shot</code>             \u2013              <p>Create a shot using parsed shot data.</p> </li> <li> <code>create_thumbnail</code>             \u2013              <p>This method may be overriden and it is called when the thumbnail</p> </li> <li> <code>extract_plugin_values</code>             \u2013              <p>Serialize plugin state and write it to a JSON file for debugging or inspection.</p> </li> <li> <code>file_added_callback</code>             \u2013              <p>This callback is added in case there is some further functionality to</p> </li> <li> <code>file_has_convention</code>             \u2013              <p>Check if a file meets entity and naming regex conventions.</p> </li> <li> <code>file_has_entity</code>             \u2013              <p>Check if the task entity is included in the file name (if required).</p> </li> <li> <code>filter_local_files</code>             \u2013              <p>Given a path, it will return the files</p> </li> <li> <code>generate_environment_for_app</code>             \u2013              <p>Generate environment variables needed to launch an external application.</p> </li> <li> <code>get_all_tasks_data</code>             \u2013              <p>This method should be overriden. It fills the return_object</p> </li> <li> <code>get_plugin_info</code>             \u2013              <p>Return a dictionary with lists of method names and variable names.</p> </li> <li> <code>get_task_filesystem</code>             \u2013              <p>Utility function for returning the filesystem of a given task.</p> </li> <li> <code>guess_executable_for_file</code>             \u2013              <p>Guess which executable should be used to open a file based on its extension.</p> </li> <li> <code>on_item_doubleclicked_callback</code>             \u2013              <p>Placeholder for handling item double-click behavior in a GUI context.</p> </li> <li> <code>open_app_with_env</code>             \u2013              <p>Launch an application with generated environment variables.</p> </li> <li> <code>open_file_with_env</code>             \u2013              <p>Open a file with a specified executable and plugin-defined environment.</p> </li> <li> <code>parse_clip_name</code>             \u2013              <p>From a clip name in a XML or in a EDL file, it returns</p> </li> <li> <code>parse_edl_file</code>             \u2013              <p>Parse an EDL file to extract shot data.</p> </li> <li> <code>publish_version</code>             \u2013              <p>Base method for creating the logic for publishing, the return</p> </li> <li> <code>read_excel</code>             \u2013              <p>Base method for creating the logic for read and return contents of an Excel file.</p> </li> <li> <code>receive_config_data_from_app</code>             \u2013              <p>Because the user data may be passed on to the plugin on initialization,</p> </li> <li> <code>return_base_task_with_kwargs</code>             \u2013              <p>Returns a task from current plugin if using kwargs as filters.</p> </li> <li> <code>return_base_task_with_path</code>             \u2013              <p>Returns a task from current plugin if using local_path as filters.</p> </li> <li> <code>return_entity_description</code>             \u2013              <p>Return a string description of the entity (e.g., asset or shot).</p> </li> <li> <code>return_file_by_ext</code>             \u2013              <p>Return a file that matches the given extension and version pattern.</p> </li> <li> <code>return_filepack_exceptions</code>             \u2013              <p>This is a function used by the asset packager so that</p> </li> <li> <code>return_last_file</code>             \u2013              <p>Returns a tuple with the both the version and the</p> </li> <li> <code>return_last_version_file</code>             \u2013              <p>Looks at all the files with a given extension in 'path' and returns as</p> </li> <li> <code>return_last_version_number</code>             \u2013              <p>Looks at all the files in 'path' and returns as int the highest version</p> </li> <li> <code>return_maya_outliner_asset_base_nodes</code>             \u2013              <p>The plugin must send to maya all the parameters so that maya doesn't have</p> </li> <li> <code>return_maya_outliner_shot_base_nodes</code>             \u2013              <p>The plugin must send to maya all the parameters so that maya doesn't have</p> </li> <li> <code>return_next_version_name</code>             \u2013              <p>This method must be overriden according to each plugin.</p> </li> <li> <code>return_seq_and_shot_from_clipname</code>             \u2013              <p>This method is called when a EDL is parsed for an entire episode,</p> </li> <li> <code>return_task_notes</code>             \u2013              <p>Base method to create the note listing logic of a task,</p> </li> <li> <code>return_task_versions</code>             \u2013              <p>Base method to create the version listing logic of a task,</p> </li> <li> <code>return_thumbnail_url</code>             \u2013              <p>This method should be overriden according to each plugin.</p> </li> <li> <code>start_task</code>             \u2013              <p>Hook for starting a task. To be overridden as needed.</p> </li> <li> <code>validate_last_task_path</code>             \u2013              <p>Ensure the filesystem structure exists for the last-clicked task.</p> </li> <li> <code>verify_bdl_excel</code>             \u2013              <p>Validate the naming convention of a BDL Excel file.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>app_toolbars</code>               (<code>List[BaseToolbar]</code>)           \u2013            <p>List[BaseToolbar]: Instantiated application toolbars.</p> </li> <li> <code>apps</code>           \u2013            <p>Supported external applications.</p> </li> <li> <code>current_selected_files</code>               (<code>List[Path]</code>)           \u2013            <p>Currently selected file paths in the UI.</p> </li> <li> <code>current_selected_tasks</code>               (<code>List[BaseTask]</code>)           \u2013            <p>Currently selected task objects in the UI.</p> </li> <li> <code>headers</code>               (<code>List[str]</code>)           \u2013            <p>Column headers for displaying task data in the UI.</p> </li> <li> <code>last_file_clicked</code>               (<code>Optional[Path]</code>)           \u2013            <p>The most recent file the user clicked.</p> </li> <li> <code>last_task_clicked</code>               (<code>Optional[BaseTask]</code>)           \u2013            <p>The most recent task the user clicked.</p> </li> <li> <code>local_root</code>           \u2013            <p>Path: Local root directory for the project.</p> </li> <li> <code>server_root</code>           \u2013            <p>Path: Server root directory for the project.</p> </li> <li> <code>tasks</code>               (<code>List[BaseTask]</code>)           \u2013            <p>List[BaseTask]: Tasks managed by this plugin.</p> </li> <li> <code>toolbars</code>           \u2013            <p>Registered toolbars definitions.</p> </li> <li> <code>username</code>           \u2013            <p>str: Username of the plugin user.</p> </li> <li> <code>version_includes_entity</code>               (<code>bool</code>)           \u2013            <p>Whether the version name must include the entity (e.g., shot or asset) string.</p> </li> <li> <code>version_regex</code>               (<code>str</code>)           \u2013            <p>Regular expression used to identify version substrings in filenames.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin(username)","title":"<code>username</code>","text":"(<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>Username of the current user.</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.app_toolbars","title":"app_toolbars  <code>property</code>","text":"<pre><code>app_toolbars: List[BaseToolbar]\n</code></pre> <p>List[BaseToolbar]: Instantiated application toolbars.</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.apps","title":"apps  <code>property</code>","text":"<pre><code>apps\n</code></pre> <p>Supported external applications.</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.current_selected_files","title":"current_selected_files  <code>property</code> <code>writable</code>","text":"<pre><code>current_selected_files: List[Path]\n</code></pre> <p>Currently selected file paths in the UI.</p> <p>Returns:</p> <ul> <li> <code>List[Path]</code>           \u2013            <p>List[Path]: The list of file Paths the user has selected.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.current_selected_tasks","title":"current_selected_tasks  <code>property</code> <code>writable</code>","text":"<pre><code>current_selected_tasks: List[BaseTask]\n</code></pre> <p>Currently selected task objects in the UI.</p> <p>Returns:</p> <ul> <li> <code>List[BaseTask]</code>           \u2013            <p>List[BaseTask]: The list of tasks the user has selected.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.headers","title":"headers  <code>property</code>","text":"<pre><code>headers: List[str]\n</code></pre> <p>Column headers for displaying task data in the UI.</p> <p>Returns:</p> <ul> <li> <code>List[str]</code>           \u2013            <p>List[str]: List of header strings in display order.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.last_file_clicked","title":"last_file_clicked  <code>property</code> <code>writable</code>","text":"<pre><code>last_file_clicked: Optional[Path]\n</code></pre> <p>The most recent file the user clicked.</p> <p>Returns:</p> <ul> <li> <code>Optional[Path]</code>           \u2013            <p>Optional[Path]: Path of the last clicked file, or None.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.last_task_clicked","title":"last_task_clicked  <code>property</code> <code>writable</code>","text":"<pre><code>last_task_clicked: Optional[BaseTask]\n</code></pre> <p>The most recent task the user clicked.</p> <p>Returns:</p> <ul> <li> <code>Optional[BaseTask]</code>           \u2013            <p>Optional[BaseTask]: The last clicked task, or None if none selected.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.local_root","title":"local_root  <code>property</code> <code>writable</code>","text":"<pre><code>local_root\n</code></pre> <p>Path: Local root directory for the project.</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.server_root","title":"server_root  <code>property</code> <code>writable</code>","text":"<pre><code>server_root\n</code></pre> <p>Path: Server root directory for the project.</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.tasks","title":"tasks  <code>property</code> <code>writable</code>","text":"<pre><code>tasks: List[BaseTask]\n</code></pre> <p>List[BaseTask]: Tasks managed by this plugin.</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.toolbars","title":"toolbars  <code>property</code>","text":"<pre><code>toolbars\n</code></pre> <p>Registered toolbars definitions.</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.username","title":"username  <code>property</code> <code>writable</code>","text":"<pre><code>username\n</code></pre> <p>str: Username of the plugin user.</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.version_includes_entity","title":"version_includes_entity  <code>property</code> <code>writable</code>","text":"<pre><code>version_includes_entity: bool\n</code></pre> <p>Whether the version name must include the entity (e.g., shot or asset) string.</p> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if entity inclusion is enforced, False otherwise.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.version_regex","title":"version_regex  <code>property</code> <code>writable</code>","text":"<pre><code>version_regex: str\n</code></pre> <p>Regular expression used to identify version substrings in filenames.</p> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>Current version\u2010matching regex pattern.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.__del__","title":"__del__","text":"<pre><code>__del__() -&gt; None\n</code></pre> <p>This method should be called before unmounting this plugin. This method should be overriden to close up connections, like shotgun or maya instances.</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.after_publish","title":"after_publish","text":"<pre><code>after_publish(*args, **kwargs) -&gt; None\n</code></pre> <p>Hook called after publishing process completes.</p> <p>Parameters:</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.after_publish(*args)","title":"<code>*args</code>","text":"(<code>Any</code>, default:                   <code>()</code> )           \u2013            <p>Positional arguments.</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.after_publish(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Keyword arguments.</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.browse_note_data","title":"browse_note_data","text":"<pre><code>browse_note_data() -&gt; None\n</code></pre> <p>This method should be overriden according to each plugin. This opens the note in the plugin's database</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.browse_task_data","title":"browse_task_data","text":"<pre><code>browse_task_data() -&gt; None\n</code></pre> <p>This method should be overriden according to each plugin. This opens the task in the plugin's database</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.browse_version_data","title":"browse_version_data","text":"<pre><code>browse_version_data() -&gt; None\n</code></pre> <p>This method should be overriden according to each plugin. This opens the version in the plugin's database</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.check_version_is_published","title":"check_version_is_published","text":"<pre><code>check_version_is_published(version: Path) -&gt; bool\n</code></pre> <p>Determine whether a given version file has already been published.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if published; False otherwise.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.check_version_is_published(version)","title":"<code>version</code>","text":"(<code>Path</code>)           \u2013            <p>File path of the version to check.</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.copy_edl_files_to_server","title":"copy_edl_files_to_server","text":"<pre><code>copy_edl_files_to_server(shot_data: dict[str, Any]) -&gt; None\n</code></pre> <p>Copy EDL-associated video and audio files to the server location.</p> <p>Parameters:</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.copy_edl_files_to_server(shot_data)","title":"<code>shot_data</code>","text":"(<code>dict[str, Any]</code>)           \u2013            <p>Dictionary containing keys 'video_file' and 'server_path'.</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.create_assets_from_bdl","title":"create_assets_from_bdl","text":"<pre><code>create_assets_from_bdl(dict_with_items: dict[str, Any], excel_file: Path) -&gt; None\n</code></pre> <p>Receives an standarized dictionary that holds the data for creating assets. It yields assets that were successfully created.</p> <p>Parameters:</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.create_assets_from_bdl(dict_with_items)","title":"<code>dict_with_items</code>","text":"(<code>dict[str, Any]</code>)           \u2013            <p>Structured asset data.</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.create_assets_from_bdl(excel_file)","title":"<code>excel_file</code>","text":"(<code>Path</code>)           \u2013            <p>Path to original Excel file.</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.create_dir_if_missing","title":"create_dir_if_missing","text":"<pre><code>create_dir_if_missing(path: Path, task: Optional[BaseTask] = None) -&gt; bool\n</code></pre> <p>Create a directory (and its defined subfolders) if it does not exist.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if creation succeeded or already existed; False on error.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.create_dir_if_missing(path)","title":"<code>path</code>","text":"(<code>Path</code>)           \u2013            <p>The directory to ensure exists.</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.create_dir_if_missing(task)","title":"<code>task</code>","text":"(<code>BaseTask</code>, default:                   <code>None</code> )           \u2013            <p>Task whose <code>task_subfolders</code> define extra subfolders to create. Defaults to <code>self.last_task_clicked</code>.</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.create_shot","title":"create_shot","text":"<pre><code>create_shot(shot_data: dict[str, Any]) -&gt; None\n</code></pre> <p>Create a shot using parsed shot data.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>NotImplementedError</code>             \u2013            <p>Must be implemented in subclass.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.create_shot(shot_data)","title":"<code>shot_data</code>","text":"(<code>dict[str, Any]</code>)           \u2013            <p>Dictionary of shot attributes.</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.create_thumbnail","title":"create_thumbnail  <code>classmethod</code>","text":"<pre><code>create_thumbnail(task: BaseTask) -&gt; bool\n</code></pre> <p>This method may be overriden and it is called when the thumbnail for a task cannot be synced because it is not in the server yet. Returns True on success</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if creation and resizing succeeded, False otherwise.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.create_thumbnail(task)","title":"<code>task</code>","text":"(<code>BaseTask</code>)           \u2013            <p>Task for which to create the thumbnail.</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.extract_plugin_values","title":"extract_plugin_values","text":"<pre><code>extract_plugin_values() -&gt; None\n</code></pre> <p>Serialize plugin state and write it to a JSON file for debugging or inspection.</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.file_added_callback","title":"file_added_callback","text":"<pre><code>file_added_callback() -&gt; None\n</code></pre> <p>This callback is added in case there is some further functionality to add in a per plugin level. Originally requested for a change in the DB in the Grisu plugin. File added -&gt; task updated to IP.</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.file_has_convention","title":"file_has_convention","text":"<pre><code>file_has_convention(file: Path, task: Optional[BaseTask] = None) -&gt; bool\n</code></pre> <p>Check if a file meets entity and naming regex conventions.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if file meets convention; otherwise False.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.file_has_convention(file)","title":"<code>file</code>","text":"(<code>Path</code>)           \u2013            <p>File to validate.</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.file_has_convention(task)","title":"<code>task</code>","text":"(<code>Optional[BaseTask]</code>, default:                   <code>None</code> )           \u2013            <p>Task context. Defaults to last clicked.</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.file_has_entity","title":"file_has_entity","text":"<pre><code>file_has_entity(file: Path, task: Optional[BaseTask] = None) -&gt; bool\n</code></pre> <p>Check if the task entity is included in the file name (if required).</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if the entity name is found or not required.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.file_has_entity(file)","title":"<code>file</code>","text":"(<code>Path</code>)           \u2013            <p>File to check.</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.file_has_entity(task)","title":"<code>task</code>","text":"(<code>Optional[BaseTask]</code>, default:                   <code>None</code> )           \u2013            <p>Task context. Defaults to last clicked.</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.filter_local_files","title":"filter_local_files","text":"<pre><code>filter_local_files(local_path: Path, ext: str | Iterable[str] = [''], task: Optional[BaseTask] = None) -&gt; list[Path]\n</code></pre> <p>Given a path, it will return the files that follow the stablished conventions</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[Path]</code>           \u2013            <p>list[Path]: List of files matching conventions and extensions.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.filter_local_files(local_path)","title":"<code>local_path</code>","text":"(<code>Path</code>)           \u2013            <p>The directory to search in.</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.filter_local_files(ext)","title":"<code>ext</code>","text":"(<code>Union[str, Iterable[str]]</code>, default:                   <code>['']</code> )           \u2013            <p>Valid file extensions to include.</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.filter_local_files(task)","title":"<code>task</code>","text":"(<code>BaseTask</code>, default:                   <code>None</code> )           \u2013            <p>Task context to validate conventions. Defaults to last clicked task.</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.generate_environment_for_app","title":"generate_environment_for_app","text":"<pre><code>generate_environment_for_app(task: Optional[BaseTask] = None) -&gt; dict[str, str]\n</code></pre> <p>Generate environment variables needed to launch an external application.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>dict[str, str]</code>           \u2013            <p>dict[str, str]: Dictionary of environment variables.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.generate_environment_for_app(task)","title":"<code>task</code>","text":"(<code>Optional[BaseTask]</code>, default:                   <code>None</code> )           \u2013            <p>Task context to embed into environment. Defaults to None.</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.get_all_tasks_data","title":"get_all_tasks_data","text":"<pre><code>get_all_tasks_data(return_object: dict, callback: Callable = None) -&gt; None\n</code></pre> <p>This method should be overriden. It fills the return_object so that it can be accesed when threaded and runs a callback</p> <p>Parameters:</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.get_all_tasks_data(return_object)","title":"<code>return_object</code>","text":"(<code>Dict</code>)           \u2013            <p>A container that will be filled with the retrieved task data.</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.get_all_tasks_data(callback)","title":"<code>callback</code>","text":"(<code>Callable</code>, default:                   <code>None</code> )           \u2013            <p>A function to call once data retrieval is complete.</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.get_plugin_info","title":"get_plugin_info","text":"<pre><code>get_plugin_info() -&gt; dict[str, list[str]]\n</code></pre> <p>Return a dictionary with lists of method names and variable names.</p> <p>Returns:</p> <ul> <li> <code>dict[str, list[str]]</code>           \u2013            <p>dict[str, list[str]]: Dictionary with 'methods' and 'variables' as keys.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.get_task_filesystem","title":"get_task_filesystem","text":"<pre><code>get_task_filesystem() -&gt; tuple[Path, Path]\n</code></pre> <p>Utility function for returning the filesystem of a given task. Retrieve the local and server filesystem roots for the current task.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>tuple[Path, Path]</code>           \u2013            <p>tuple[Path, Path]: (local_path, server_path) for the task.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.get_task_filesystem(*args)","title":"<code>*args</code>","text":"\u2013            <p>Positional arguments for filesystem resolution.</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.get_task_filesystem(**kwargs)","title":"<code>**kwargs</code>","text":"\u2013            <p>Keyword arguments for filesystem resolution.</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.guess_executable_for_file","title":"guess_executable_for_file","text":"<pre><code>guess_executable_for_file(path: str | Path) -&gt; Optional[str]\n</code></pre> <p>Guess which executable should be used to open a file based on its extension.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Optional[str]</code>           \u2013            <p>Optional[str]: Path to the executable, or None if no match found.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.guess_executable_for_file(path)","title":"<code>path</code>","text":"(<code>str | Path</code>)           \u2013            <p>Path to the file to analyze.</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.on_item_doubleclicked_callback","title":"on_item_doubleclicked_callback","text":"<pre><code>on_item_doubleclicked_callback() -&gt; None\n</code></pre> <p>Placeholder for handling item double-click behavior in a GUI context.</p> <p>Intended to be overridden by subclasses or externally bound.</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.open_app_with_env","title":"open_app_with_env","text":"<pre><code>open_app_with_env(executable: Optional[str] = None, environ: Optional[str] = None) -&gt; None\n</code></pre> <p>Launch an application with generated environment variables.</p> <p>Parameters:</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.open_app_with_env(executable)","title":"<code>executable</code>","text":"(<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>Executable path. Overridden by environ if provided.</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.open_app_with_env(environ)","title":"<code>environ</code>","text":"(<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>Environment variable key to retrieve executable from.</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.open_file_with_env","title":"open_file_with_env","text":"<pre><code>open_file_with_env(path: str | Path, executable: str) -&gt; None\n</code></pre> <p>Open a file with a specified executable and plugin-defined environment.</p> <p>Parameters:</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.open_file_with_env(path)","title":"<code>path</code>","text":"(<code>str | Path</code>)           \u2013            <p>File path to open.</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.open_file_with_env(executable)","title":"<code>executable</code>","text":"(<code>str</code>)           \u2013            <p>Path to the application executable.</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.parse_clip_name","title":"parse_clip_name","text":"<pre><code>parse_clip_name(clip_name: str) -&gt; Any\n</code></pre> <p>From a clip name in a XML or in a EDL file, it returns the number of the episode, sequence and shot</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Any</code> (              <code>Any</code> )          \u2013            <p>Expected to return episode, sequence, and shot identifiers.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>NotImplementedError</code>             \u2013            <p>Must be implemented in subclass.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.parse_clip_name(clip_name)","title":"<code>clip_name</code>","text":"(<code>str</code>)           \u2013            <p>The input clip name.</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.parse_edl_file","title":"parse_edl_file","text":"<pre><code>parse_edl_file(source_edl: Path, source_video: Path) -&gt; Iterator[dict[Any, Any]]\n</code></pre> <p>Parse an EDL file to extract shot data.</p> <p>Parameters:</p> <p>Yields:</p> <ul> <li> <code>dict[Any, Any]</code>           \u2013            <p>dict[Any, Any]: A dictionary representing each shot.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>NotImplementedError</code>             \u2013            <p>Must be implemented in subclass.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.parse_edl_file(source_edl)","title":"<code>source_edl</code>","text":"(<code>Path</code>)           \u2013            <p>Path to the EDL file.</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.parse_edl_file(source_video)","title":"<code>source_video</code>","text":"(<code>Path</code>)           \u2013            <p>Path to the reference video.</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.publish_version","title":"publish_version","text":"<pre><code>publish_version(task: BaseTask, version: Path) -&gt; dict\n</code></pre> <p>Base method for creating the logic for publishing, the return object should be a dictionary with the following structure:</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>dict</code>           \u2013            <p>Dict[str, Any]: A result dict with: {     \"success\": bool,     \"message\": str,     \"error\": Optional[str] }</p> </li> </ul>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.publish_version(task)","title":"<code>task</code>","text":"(<code>BaseTask</code>)           \u2013            <p>The task being published.</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.publish_version(version)","title":"<code>version</code>","text":"(<code>Path</code>)           \u2013            <p>Path to the version file.</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.read_excel","title":"read_excel","text":"<pre><code>read_excel(excel: Path) -&gt; tuple[list[Any], dict[Any, Any]]\n</code></pre> <p>Base method for creating the logic for read and return contents of an Excel file.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>tuple[list[Any], dict[Any, Any]]</code>           \u2013            <p>tuple[list[Any], dict[str, Any]]: A list of rows and a dictionary of parsed data.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.read_excel(excel)","title":"<code>excel</code>","text":"(<code>Path</code>)           \u2013            <p>Path to the Excel file.</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.receive_config_data_from_app","title":"receive_config_data_from_app","text":"<pre><code>receive_config_data_from_app(*args, **kwargs) -&gt; None\n</code></pre> <p>Because the user data may be passed on to the plugin on initialization, we have this function that will handle in a per plugin basis the logic.</p> <p>Parameters:</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.receive_config_data_from_app(*args)","title":"<code>*args</code>","text":"(<code>Any</code>, default:                   <code>()</code> )           \u2013            <p>Positional arguments.</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.receive_config_data_from_app(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Configuration data passed by the app.</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.return_base_task_with_kwargs","title":"return_base_task_with_kwargs","text":"<pre><code>return_base_task_with_kwargs(**kwargs) -&gt; Optional[BaseTask]\n</code></pre> <p>Returns a task from current plugin if using kwargs as filters.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Optional[BaseTask]</code>           \u2013            <p>Optional[BaseTask]: Matching task or None.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.return_base_task_with_kwargs(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Attribute-value pairs to match against BaseTask attributes.</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.return_base_task_with_path","title":"return_base_task_with_path","text":"<pre><code>return_base_task_with_path(local_path: Path) -&gt; Optional[BaseTask]\n</code></pre> <p>Returns a task from current plugin if using local_path as filters.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Optional[BaseTask]</code>           \u2013            <p>Optional[BaseTask]: The matching BaseTask, if any.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.return_base_task_with_path(local_path)","title":"<code>local_path</code>","text":"(<code>Path</code>)           \u2013            <p>Path to match against task local paths.</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.return_entity_description","title":"return_entity_description","text":"<pre><code>return_entity_description(task: BaseTask, force_stop: Callable[[], bool]) -&gt; Optional[str]\n</code></pre> <p>Return a string description of the entity (e.g., asset or shot).</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Optional[str]</code>           \u2013            <p>Optional[str]: The entity description, if any.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.return_entity_description(task)","title":"<code>task</code>","text":"(<code>BaseTask</code>)           \u2013            <p>The task associated with the entity.</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.return_entity_description(force_stop)","title":"<code>force_stop</code>","text":"(<code>Callable[[], bool]</code>)           \u2013            <p>Callback to interrupt processing.</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.return_file_by_ext","title":"return_file_by_ext","text":"<pre><code>return_file_by_ext(file: Path, ext: str) -&gt; Path\n</code></pre> <p>Return a file that matches the given extension and version pattern.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Path</code> (              <code>Path</code> )          \u2013            <p>Matching file or fallback template path.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.return_file_by_ext(file)","title":"<code>file</code>","text":"(<code>Path</code>)           \u2013            <p>Input file path.</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.return_file_by_ext(ext)","title":"<code>ext</code>","text":"(<code>str</code>)           \u2013            <p>Target extension to match.</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.return_filepack_exceptions","title":"return_filepack_exceptions","text":"<pre><code>return_filepack_exceptions() -&gt; list[str]\n</code></pre> <p>This is a function used by the asset packager so that each plugin can define how to return an exception of files to be packed.</p> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>list[str]: A list of exception file names or patterns.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.return_last_file","title":"return_last_file","text":"<pre><code>return_last_file(ext: Iterable[str], subdir: Path = Path(), template_failed: bool = True, task: Optional[BaseTask] = None) -&gt; tuple[int, Path]\n</code></pre> <p>Returns a tuple with the both the version and the last file of a given task. Defaults to the task's localpath, but can receive a path (generaly a subpath of the local path).</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>tuple[int, Path]</code>           \u2013            <p>tuple[int, Path]: Tuple of version number and file path.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.return_last_file(ext)","title":"<code>ext</code>","text":"(<code>Iterable[str]</code>)           \u2013            <p>Valid file extensions.</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.return_last_file(subdir)","title":"<code>subdir</code>","text":"(<code>Path</code>, default:                   <code>Path()</code> )           \u2013            <p>Subdirectory to look inside. Defaults to Path().</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.return_last_file(template_failed)","title":"<code>template_failed</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True and no file is found, try template. Defaults to True.</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.return_last_file(task)","title":"<code>task</code>","text":"(<code>Optional[BaseTask]</code>, default:                   <code>None</code> )           \u2013            <p>Task context. Defaults to last clicked.</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.return_last_version_file","title":"return_last_version_file","text":"<pre><code>return_last_version_file(path: Path, ext: Iterable[str]) -&gt; Optional[Path]\n</code></pre> <p>Looks at all the files with a given extension in 'path' and returns as Path the file that has the highest version number that matches the version_regex.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Optional[Path]</code>           \u2013            <p>Optional[Path]: Path to highest-versioned file, or None.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.return_last_version_file(path)","title":"<code>path</code>","text":"(<code>Path</code>)           \u2013            <p>Directory to search.</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.return_last_version_file(ext)","title":"<code>ext</code>","text":"(<code>Iterable[str]</code>)           \u2013            <p>File extensions to match.</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.return_last_version_number","title":"return_last_version_number","text":"<pre><code>return_last_version_number(path: Path) -&gt; int\n</code></pre> <p>Looks at all the files in 'path' and returns as int the highest version number that matches the version_regex.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>int</code> (              <code>int</code> )          \u2013            <p>The maximum version number found. Returns 0 if none.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.return_last_version_number(path)","title":"<code>path</code>","text":"(<code>Path</code>)           \u2013            <p>Directory to search for versioned files.</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.return_maya_outliner_asset_base_nodes","title":"return_maya_outliner_asset_base_nodes","text":"<pre><code>return_maya_outliner_asset_base_nodes(*args, **kwargs) -&gt; Optional[list[str]]\n</code></pre> <p>The plugin must send to maya all the parameters so that maya doesn't have to query any database to get the required values. All not-default nodes must be under one of these nodes.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Optional[list[str]]</code>           \u2013            <p>Optional[list[str]]: List of node strings to be used as parents in Maya's outliner.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.return_maya_outliner_asset_base_nodes(*args)","title":"<code>*args</code>","text":"(<code>Any</code>, default:                   <code>()</code> )           \u2013            <p>Positional arguments.</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.return_maya_outliner_asset_base_nodes(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Keyword arguments, expects 'link_name' to identify asset group.</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.return_maya_outliner_shot_base_nodes","title":"return_maya_outliner_shot_base_nodes","text":"<pre><code>return_maya_outliner_shot_base_nodes(*args, **kwargs) -&gt; list[str]\n</code></pre> <p>The plugin must send to maya all the parameters so that maya doesn't have to query any database to get the required values.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>list[str]: Top-level node names used in Maya for organizing shots.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.return_maya_outliner_shot_base_nodes(*args)","title":"<code>*args</code>","text":"(<code>Any</code>, default:                   <code>()</code> )           \u2013            <p>Positional arguments.</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.return_maya_outliner_shot_base_nodes(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Keyword arguments.</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.return_next_version_name","title":"return_next_version_name","text":"<pre><code>return_next_version_name(ext: Iterable, task: BaseTask = None) -&gt; dict\n</code></pre> <p>This method must be overriden according to each plugin. it should return a dictionary like so: {     \"local_path\": \"path there the file goes\",     \"file_name\": \"name without extension\",     \"previous_file\": \"copy the previous version\" }</p> <p>If there is no previous version, it should return a path where the templates are so that the user can choose a template form a QFileDialog. If the path is None, the QFileDialog will pop up in the root.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>dict</code>           \u2013            <p>Dict[str, Any]: Mapping with keys described above, or <code>None</code></p> </li> <li> <code>dict</code>           \u2013            <p>if default logic is not applicable.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.return_next_version_name(ext)","title":"<code>ext</code>","text":"(<code>Iterable[str]</code>)           \u2013            <p>Allowed file extensions.</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.return_next_version_name(task)","title":"<code>task</code>","text":"(<code>BaseTask</code>, default:                   <code>None</code> )           \u2013            <p>Task context. Defaults to last clicked.</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.return_seq_and_shot_from_clipname","title":"return_seq_and_shot_from_clipname","text":"<pre><code>return_seq_and_shot_from_clipname(clip_name: str) -&gt; Any\n</code></pre> <p>This method is called when a EDL is parsed for an entire episode, where the info about which sequence and shot lives in the name of the clip name, for a edl file. This method is called when self._episode_edl_workflow is True.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>Any</code> )          \u2013            <p>Override expected to return values.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.return_seq_and_shot_from_clipname(clip_name)","title":"<code>clip_name</code>","text":"(<code>str</code>)           \u2013            <p>The clip name from which to extract episode data.</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.return_task_notes","title":"return_task_notes","text":"<pre><code>return_task_notes(task: BaseTask, force_stop: Callable[[], bool]) -&gt; list[dict[str, Any]]\n</code></pre> <p>Base method to create the note listing logic of a task, the returned object must be a list with the following structure:</p> <p>[{     \"content\" : str,     \"created_by\" : str or None,     \"created_at\" : str or None,     \"attachments\" : list[dict[\"url_open\":str,\"url_image\":str,\"bytes\":str,\"path\":str],]     \"url\" : str }]</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[dict[str, Any]]</code>           \u2013            <p>list[dict[str, Any]]: A list of note dictionaries.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.return_task_notes(task)","title":"<code>task</code>","text":"(<code>BaseTask</code>)           \u2013            <p>The task to retrieve notes for.</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.return_task_notes(force_stop)","title":"<code>force_stop</code>","text":"(<code>Callable[[], bool]</code>)           \u2013            <p>Callback to interrupt processing.</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.return_task_versions","title":"return_task_versions","text":"<pre><code>return_task_versions(task: BaseTask) -&gt; list[dict[str, Any]]\n</code></pre> <p>Base method to create the version listing logic of a task, the returned object must be a list with the following structure:</p> <p>[{     \"content\" : str,     \"created_by\" : str  or None,     \"created_at\" : str or None,     \"attachments\" : dict[\"url\",\"bytes\" or \"url\"],     \"url\" : str     \"reply\" : list[dict] }]</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[dict[str, Any]]</code>           \u2013            <p>list[dict[str, Any]]: A list of version dictionaries.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.return_task_versions(task)","title":"<code>task</code>","text":"(<code>BaseTask</code>)           \u2013            <p>The task to retrieve versions for.</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.return_thumbnail_url","title":"return_thumbnail_url","text":"<pre><code>return_thumbnail_url() -&gt; Optional[str]\n</code></pre> <p>This method should be overriden according to each plugin. This refresh the url thumbnail in the plugin's database</p> <p>Returns:</p> <ul> <li> <code>Optional[str]</code>           \u2013            <p>Optional[str]: URL string if available.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.start_task","title":"start_task","text":"<pre><code>start_task() -&gt; None\n</code></pre> <p>Hook for starting a task. To be overridden as needed.</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.validate_last_task_path","title":"validate_last_task_path","text":"<pre><code>validate_last_task_path(task: Optional[BaseTask] = None) -&gt; Path\n</code></pre> <p>Ensure the filesystem structure exists for the last-clicked task.</p> <p>If necessary, creates missing directories (including any subfolders defined in <code>task_subfolders</code>).</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Path</code> (              <code>Path</code> )          \u2013            <p>The validated (and possibly newly created) task path.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.validate_last_task_path(task)","title":"<code>task</code>","text":"(<code>BaseTask</code>, default:                   <code>None</code> )           \u2013            <p>Task to validate. Defaults to <code>self.last_task_clicked</code>.</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.verify_bdl_excel","title":"verify_bdl_excel  <code>classmethod</code>","text":"<pre><code>verify_bdl_excel(excel: Path) -&gt; tuple[bool, str]\n</code></pre> <p>Validate the naming convention of a BDL Excel file.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>tuple[bool, str]</code>           \u2013            <p>tuple[bool, str]: True and code string if valid; False and reason otherwise.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BasePlugin.verify_bdl_excel(excel)","title":"<code>excel</code>","text":"(<code>Path</code>)           \u2013            <p>The Excel file to verify.</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BaseTask","title":"BaseTask","text":"<pre><code>BaseTask(name: str, link_name: str, local_path: Path, prev_task_server: Path, thumbnail: BaseThumbnail, data_to_show, *args, **kwargs)\n</code></pre> <p>Represents a unit of work within a plugin, including paths and metadata.</p> <p>Attributes:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Task name (e.g., 'refine', 'model').</p> </li> <li> <code>link_name</code>               (<code>str</code>)           \u2013            <p>Linked entity name.</p> </li> <li> <code>local_path</code>               (<code>Path</code>)           \u2013            <p>Local path of the task.</p> </li> <li> <code>prev_task_server</code>               (<code>Path</code>)           \u2013            <p>Server path of previous task.</p> </li> <li> <code>thumbnail</code>               (<code>BaseThumbnail</code>)           \u2013            <p>Thumbnail metadata.</p> </li> <li> <code>data_to_show</code>               (<code>List[Any]</code>)           \u2013            <p>Data rows to display.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>deserialize</code>             \u2013              <p>Populate this object from serialized dictionary or JSON string.</p> </li> <li> <code>serialize</code>             \u2013              <p>Serialize the task object's public attributes to a dictionary.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BaseTask.data_to_show","title":"data_to_show  <code>property</code> <code>writable</code>","text":"<pre><code>data_to_show: List[Any]\n</code></pre> <p>Get the data to show in UI list.</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BaseTask.link_name","title":"link_name  <code>property</code> <code>writable</code>","text":"<pre><code>link_name: str\n</code></pre> <p>Get the link name.</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BaseTask.local_path","title":"local_path  <code>property</code> <code>writable</code>","text":"<pre><code>local_path: Path\n</code></pre> <p>Get the task's local path.</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BaseTask.name","title":"name  <code>property</code> <code>writable</code>","text":"<pre><code>name: str\n</code></pre> <p>Get the task name.</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BaseTask.thumbnail","title":"thumbnail  <code>property</code> <code>writable</code>","text":"<pre><code>thumbnail\n</code></pre> <p>Get the thumbnail object.</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BaseTask.deserialize","title":"deserialize","text":"<pre><code>deserialize(data: Union[str, Dict[str, Any]]) -&gt; None\n</code></pre> <p>Populate this object from serialized dictionary or JSON string.</p> <p>Parameters:</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BaseTask.deserialize(data)","title":"<code>data</code>","text":"(<code>Union[str, Dict[str, Any]]</code>)           \u2013            <p>JSON string or dict.</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BaseTask.serialize","title":"serialize","text":"<pre><code>serialize() -&gt; Dict[str, Any]\n</code></pre> <p>Serialize the task object's public attributes to a dictionary.</p> <p>Returns:</p> <ul> <li> <code>Dict[str, Any]</code>           \u2013            <p>Dict[str, Any]: Serialized key-value mapping.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BaseThumbnail","title":"BaseThumbnail","text":"<pre><code>BaseThumbnail(id: int, url: str = None, path: Path = None, on_refresh_url=None, *args, **kwargs)\n</code></pre> <p>Represents a thumbnail resource for a task.</p> <p>Attributes:</p> <ul> <li> <code>id</code>               (<code>int</code>)           \u2013            <p>Unique identifier for the thumbnail.</p> </li> <li> <code>on_refresh_url</code>               (<code>Optional[Callable[[], str]]</code>)           \u2013            <p>Callback to refresh URL.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>refresh_url</code>             \u2013              <p>Refresh and return the thumbnail URL via callback.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BaseThumbnail.path","title":"path  <code>property</code>","text":"<pre><code>path\n</code></pre> <p>Get the thumbnail local path.</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BaseThumbnail.url","title":"url  <code>property</code>","text":"<pre><code>url\n</code></pre> <p>Get the thumbnail URL.</p>"},{"location":"dev/task_schema/plugins/base_plugin/#plugins.base_plugin.BaseThumbnail.refresh_url","title":"refresh_url","text":"<pre><code>refresh_url() -&gt; Optional[str]\n</code></pre> <p>Refresh and return the thumbnail URL via callback.</p> <p>Returns:</p> <ul> <li> <code>Optional[str]</code>           \u2013            <p>Optional[str]: Updated URL.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/blender_test_plugin/","title":"blender_test_plugin","text":""},{"location":"dev/task_schema/plugins/blender_test_plugin/#blender_test_plugin","title":"<code>blender_test_plugin</code>","text":""},{"location":"dev/task_schema/plugins/blender_test_plugin/#plugins.blender_test_plugin","title":"blender_test_plugin","text":""},{"location":"dev/task_schema/plugins/furrytails_plugin/","title":"furrytails_plugin","text":""},{"location":"dev/task_schema/plugins/furrytails_plugin/#furrytails_plugin","title":"<code>furrytails_plugin</code>","text":""},{"location":"dev/task_schema/plugins/furrytails_plugin/#plugins.furrytails_plugin","title":"furrytails_plugin","text":""},{"location":"dev/task_schema/plugins/furrytailsnew_plugin/","title":"furrytailsnew_plugin","text":""},{"location":"dev/task_schema/plugins/furrytailsnew_plugin/#furrytailsnew_plugin","title":"<code>furrytailsnew_plugin</code>","text":""},{"location":"dev/task_schema/plugins/furrytailsnew_plugin/#plugins.furrytailsnew_plugin","title":"furrytailsnew_plugin","text":"<p>Classes:</p> <ul> <li> <code>FurryTailsNewPlugin</code>           \u2013            </li> </ul>"},{"location":"dev/task_schema/plugins/furrytailsnew_plugin/#plugins.furrytailsnew_plugin.FurryTailsNewPlugin","title":"FurryTailsNewPlugin","text":"<pre><code>FurryTailsNewPlugin(*args, **kwargs)\n</code></pre> <p>Methods:</p> <ul> <li> <code>return_last_version_file</code>             \u2013              <p>Looks at all the files with a given extension in 'path' and returns as</p> </li> </ul>"},{"location":"dev/task_schema/plugins/furrytailsnew_plugin/#plugins.furrytailsnew_plugin.FurryTailsNewPlugin.return_last_version_file","title":"return_last_version_file","text":"<pre><code>return_last_version_file(path: Path, ext: Iterable[str]) -&gt; Path | None\n</code></pre> <p>Looks at all the files with a given extension in 'path' and returns as Path the file that has the highest version number that matches the version_regex.</p>"},{"location":"dev/task_schema/plugins/generic2d_plugin/","title":"generic2d_plugin","text":""},{"location":"dev/task_schema/plugins/generic2d_plugin/#generic2d_plugin","title":"<code>generic2d_plugin</code>","text":""},{"location":"dev/task_schema/plugins/generic2d_plugin/#plugins.generic2d_plugin","title":"generic2d_plugin","text":""},{"location":"dev/task_schema/plugins/google_plugin/","title":"google_plugin","text":""},{"location":"dev/task_schema/plugins/google_plugin/#google_plugin","title":"<code>google_plugin</code>","text":""},{"location":"dev/task_schema/plugins/google_plugin/#plugins.google_plugin","title":"google_plugin","text":"<p>Classes:</p> <ul> <li> <code>GooglePlugin</code>           \u2013            </li> </ul>"},{"location":"dev/task_schema/plugins/google_plugin/#plugins.google_plugin.GooglePlugin","title":"GooglePlugin","text":"<pre><code>GooglePlugin(*args, **kwargs)\n</code></pre> <p>Methods:</p> <ul> <li> <code>collect_data</code>             \u2013              <p>example: compile_code = [\"B1\",4,5]</p> </li> <li> <code>open_sheet</code>             \u2013              <p>link (str): sheet's name or sheet's link</p> </li> <li> <code>open_worksheet</code>             \u2013              <p>worksheet (int or str): id(int) or name(str)</p> </li> </ul>"},{"location":"dev/task_schema/plugins/google_plugin/#plugins.google_plugin.GooglePlugin.collect_data","title":"collect_data","text":"<pre><code>collect_data(all_tasks_data, task_data, compile_code) -&gt; str\n</code></pre> <p>example: compile_code = [\"B1\",4,5]</p>"},{"location":"dev/task_schema/plugins/google_plugin/#plugins.google_plugin.GooglePlugin.open_sheet","title":"open_sheet","text":"<pre><code>open_sheet(link) -&gt; Spreadsheet\n</code></pre> <p>link (str): sheet's name or sheet's link</p>"},{"location":"dev/task_schema/plugins/google_plugin/#plugins.google_plugin.GooglePlugin.open_worksheet","title":"open_worksheet","text":"<pre><code>open_worksheet(sheet, worksheet_id=0, all_worksheet=False) -&gt; list\n</code></pre> <p>worksheet (int or str): id(int) or name(str)</p>"},{"location":"dev/task_schema/plugins/grisu_plugin/","title":"grisu_plugin","text":""},{"location":"dev/task_schema/plugins/grisu_plugin/#grisu_plugin","title":"<code>grisu_plugin</code>","text":""},{"location":"dev/task_schema/plugins/grisu_plugin/#plugins.grisu_plugin","title":"grisu_plugin","text":""},{"location":"dev/task_schema/plugins/gwaio_plugin/","title":"gwaio_plugin","text":""},{"location":"dev/task_schema/plugins/gwaio_plugin/#gwaio_plugin","title":"<code>gwaio_plugin</code>","text":""},{"location":"dev/task_schema/plugins/gwaio_plugin/#plugins.gwaio_plugin","title":"gwaio_plugin","text":""},{"location":"dev/task_schema/plugins/letrabots_plugin/","title":"letrabots_plugin","text":""},{"location":"dev/task_schema/plugins/letrabots_plugin/#letrabots_plugin","title":"<code>letrabots_plugin</code>","text":""},{"location":"dev/task_schema/plugins/letrabots_plugin/#plugins.letrabots_plugin","title":"letrabots_plugin","text":""},{"location":"dev/task_schema/plugins/maya_unreal_test_plugin/","title":"maya_unreal_test_plugin","text":""},{"location":"dev/task_schema/plugins/maya_unreal_test_plugin/#maya_unreal_test_plugin","title":"<code>maya_unreal_test_plugin</code>","text":""},{"location":"dev/task_schema/plugins/maya_unreal_test_plugin/#plugins.maya_unreal_test_plugin","title":"maya_unreal_test_plugin","text":""},{"location":"dev/task_schema/plugins/meteoheroes_plugin/","title":"meteoheroes_plugin","text":""},{"location":"dev/task_schema/plugins/meteoheroes_plugin/#meteoheroes_plugin","title":"<code>meteoheroes_plugin</code>","text":""},{"location":"dev/task_schema/plugins/meteoheroes_plugin/#plugins.meteoheroes_plugin","title":"meteoheroes_plugin","text":""},{"location":"dev/task_schema/plugins/miniraja_plugin/","title":"miniraja_plugin","text":""},{"location":"dev/task_schema/plugins/miniraja_plugin/#miniraja_plugin","title":"<code>miniraja_plugin</code>","text":""},{"location":"dev/task_schema/plugins/miniraja_plugin/#plugins.miniraja_plugin","title":"miniraja_plugin","text":""},{"location":"dev/task_schema/plugins/nivis_plugin/","title":"nivis_plugin","text":""},{"location":"dev/task_schema/plugins/nivis_plugin/#nivis_plugin","title":"<code>nivis_plugin</code>","text":""},{"location":"dev/task_schema/plugins/nivis_plugin/#plugins.nivis_plugin","title":"nivis_plugin","text":""},{"location":"dev/task_schema/plugins/piloto_plugin/","title":"piloto_plugin","text":""},{"location":"dev/task_schema/plugins/piloto_plugin/#piloto_plugin","title":"<code>piloto_plugin</code>","text":""},{"location":"dev/task_schema/plugins/piloto_plugin/#plugins.piloto_plugin","title":"piloto_plugin","text":""},{"location":"dev/task_schema/plugins/shotgrid_plugin/","title":"shotgrid_plugin","text":""},{"location":"dev/task_schema/plugins/shotgrid_plugin/#shotgrid_plugin","title":"<code>shotgrid_plugin</code>","text":""},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin","title":"shotgrid_plugin","text":"<p>Classes:</p> <ul> <li> <code>ShotgridInstance</code>           \u2013            <p>Context manager for handling a Shotgun API session.</p> </li> <li> <code>ShotgridPlugin</code>           \u2013            <p>Plugin for integration with Autodesk ShotGrid.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridInstance","title":"ShotgridInstance","text":"<pre><code>ShotgridInstance(plugin: ShotgridPlugin)\n</code></pre> <p>Context manager for handling a Shotgun API session.</p> <p>This helper class is designed to manage the lifecycle of a Shotgun API instance within a with-statement. It ensures the connection is properly closed after use.</p> <p>Parameters:</p> <p>Methods:</p> <ul> <li> <code>__enter__</code>             \u2013              <p>Instantiate and return a Shotgun API instance.</p> </li> <li> <code>__exit__</code>             \u2013              <p>Clean up the Shotgun API instance.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridInstance(plugin)","title":"<code>plugin</code>","text":"(<code>ShotgridPlugin</code>)           \u2013            <p>Instance of the Shotgrid plugin.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridInstance.__enter__","title":"__enter__","text":"<pre><code>__enter__() -&gt; Shotgun\n</code></pre> <p>Instantiate and return a Shotgun API instance.</p> <p>Returns:</p> <ul> <li> <code>Shotgun</code> (              <code>Shotgun</code> )          \u2013            <p>Shotgun API instance.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridInstance.__exit__","title":"__exit__","text":"<pre><code>__exit__(exc_type: Optional[type], exc_value: Optional[BaseException], exc_tb: Optional[object]) -&gt; None\n</code></pre> <p>Clean up the Shotgun API instance.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin","title":"ShotgridPlugin","text":"<pre><code>ShotgridPlugin(*args, **kwargs)\n</code></pre> <p>Plugin for integration with Autodesk ShotGrid.</p> <p>This plugin extends the BasePlugin to support task and version management through ShotGrid. It handles querying tasks, uploading packages, retrieving notes and versions, managing custom artist entities, and other production tracking features within the launcher environment.</p> Class Attributes <p>TITLE (str): Plugin title identifier. _server_root (Path): Root path to the project's server-side filesystem. SHOTGRID_URL (str): URL endpoint for the ShotGrid instance. SHOTGRID_SCRIPT_NAME (str): Script name used for authenticating with ShotGrid API. SHOTGRID_API_KEY (str): Script-based API key for ShotGrid access. SG_PROJECT_ID (int): ShotGrid project ID used for scoping queries. SL_SERVER_PATH (Optional[Path]): Optional path used for logging or data sharing. title (str): Human-readable title for the plugin. custom_artist_entities (List[str]): List of custom entity fields used to resolve assignees. _active_entities (List[str]): Entity types used by the plugin (e.g. Shot, Asset). plugin_task_fields (List[str]): Default fields requested from each task. _discarted_task_status (List[str]): List of task statuses to ignore. _discarted_version_status (List[str]): List of version statuses to ignore. asset_task_fields_dict (Optional[Dict]): Optional dictionary for customizing task fields.</p> Instance Attributes <p>sg (Shotgun): ShotGrid API instance. _toolbars (List): List of toolbars registered by this plugin. _headers (List[str]): Column headers for task display. plugin_task_filters (List[List]): Filters applied to task queries. timelog_artist_entity_field (Optional[str]): Field used to assign timelogs to artists. publishedfile_artist_entity_field (Optional[str]): Field used to resolve artist from PublishedFiles. version_artist_entity_field (Optional[str]): Field used to assign versions to artists. custom_artist_login_field (Optional[str]): Field used to match the current username to artist. custom_artist_entity_name (Optional[str]): Name of the custom artist entity in ShotGrid. custom_artist_task_field (Optional[str]): Custom field linking tasks and artists. _starting_frame (int): Default starting frame for playblasts or versioning. _task_long_to_short_dict (Dict[str, str]): Mapping of long task names to short aliases. _upload_status (str): Default status to assign when uploading a version. _version_publish_fields (List[str]): Fields to include when publishing a version. _color_status (Dict[str, Tuple[int, int, int]]): Mapping of ShotGrid status codes to RGB colors.</p> <p>Initializes toolbars, sets up task filters, ShotGrid connection, headers, version fields and task mappings.</p> <p>Methods:</p> <ul> <li> <code>async_find</code>             \u2013              <p>Performs asynchronous paged queries on the ShotGrid API.</p> </li> <li> <code>browse_note_data</code>             \u2013              <p>This method should be overriden according to each plugin.</p> </li> <li> <code>browse_task_data</code>             \u2013              <p>This method should be overriden according to each plugin.</p> </li> <li> <code>browse_version_data</code>             \u2013              <p>This method should be overriden according to each plugin.</p> </li> <li> <code>cache_data</code>             \u2013              <p>Stores task data in a cache file.</p> </li> <li> <code>check_file_is_uploaded</code>             \u2013              <p>Check if a given file name has an associated PublishedFile in ShotGrid.</p> </li> <li> <code>check_version_is_published</code>             \u2013              <p>Check if a given version file name has already been published to ShotGrid.</p> </li> <li> <code>create_note</code>             \u2013              <p>Create a new Note entity in ShotGrid.</p> </li> <li> <code>create_pack</code>             \u2013              <p>Looks for versions that matches the data passed as args,</p> </li> <li> <code>create_pack_from_dialog</code>             \u2013              <p>Pack selected version files based on user-selected filters.</p> </li> <li> <code>create_shot</code>             \u2013              <p>Create or update a Shot entity and upload an associated version if applicable.</p> </li> <li> <code>create_thumbnail</code>             \u2013              <p>Generate and set a thumbnail for the given task.</p> </li> <li> <code>dowload_last_file_from_name</code>             \u2013              <p>Download the most recent published file whose code contains the given name.</p> </li> <li> <code>dowload_last_file_from_task</code>             \u2013              <p>Download the last file published for a given task.</p> </li> <li> <code>download_file</code>             \u2013              <p>Download a PublishedFile from ShotGrid by ID.</p> </li> <li> <code>download_last_version_from_entity</code>             \u2013              <p>Download the last uploaded MP4 movie associated with a specific entity.</p> </li> <li> <code>download_package</code>             \u2013              <p>Download a package from ShotGrid by task or package name and extract it.</p> </li> <li> <code>download_thumbnail_from_sg</code>             \u2013              <p>Download a thumbnail image from a ShotGrid entity.</p> </li> <li> <code>download_version</code>             \u2013              <p>Download the movie file from a version.</p> </li> <li> <code>download_versions_from_sg</code>             \u2013              <p>Download all version movie files (sg_uploaded_movie) for selected tasks.</p> </li> <li> <code>generate_package_name</code>             \u2013              <p>Generate a unique package name based on task and current user.</p> </li> <li> <code>get_all_tasks_data</code>             \u2013              <p>Retrieve all tasks for the specified entity type, handle caching, and invoke callback.</p> </li> <li> <code>parse_edl_file</code>             \u2013              <p>Parse an EDL file and yield shot metadata for creation or update.</p> </li> <li> <code>publish_file</code>             \u2013              <p>Upload a file as a PublishedFile entity to ShotGrid.</p> </li> <li> <code>publish_last_version</code>             \u2013              <p>Publish the last version file for the specified or last-clicked task.</p> </li> <li> <code>publish_timelog</code>             \u2013              <p>Publish a timelog entry in ShotGrid for the given task and duration.</p> </li> <li> <code>publish_version</code>             \u2013              <p>Method for creating the logic for publishing, the return</p> </li> <li> <code>receive_config_data_from_app</code>             \u2013              <p>Receives entity-type configuration data from an external application.</p> </li> <li> <code>retrieve_cached</code>             \u2013              <p>Attempts to load cached task data for the given link type.</p> </li> <li> <code>retrieve_latests_tasks</code>             \u2013              <p>Uses the cache to get its date so that only the tasks that were updated</p> </li> <li> <code>return_all_assets</code>             \u2013              <p>Retrieve all Asset entities for the configured project.</p> </li> <li> <code>return_all_episodes</code>             \u2013              <p>Retrieve all Episode entities for the configured project.</p> </li> <li> <code>return_all_packages</code>             \u2013              <p>Retrieve all PublishedFile (package) entities matching optional filters.</p> </li> <li> <code>return_all_playlists</code>             \u2013              <p>Retrieve all Playlist entities for the configured project.</p> </li> <li> <code>return_all_sequences</code>             \u2013              <p>Retrieve all Sequence entities for the configured project.</p> </li> <li> <code>return_all_shots</code>             \u2013              <p>Retrieve all Shot entities, optionally filtered, for the project.</p> </li> <li> <code>return_all_versions</code>             \u2013              <p>Retrieve all Version entities matching optional filters.</p> </li> <li> <code>return_custom_artist_entity</code>             \u2013              <p>Return the custom artist entity linked to the current user.</p> </li> <li> <code>return_data_to_show</code>             \u2013              <p>Format a ShotGrid task into a list of UI\u2010ready rows matching headers.</p> </li> <li> <code>return_entity_description</code>             \u2013              <p>Fetch the description of the entity linked to a given task.</p> </li> <li> <code>return_fields_from_entity_type</code>             \u2013              <p>Generate the list of ShotGrid fields to request based on entity type.</p> </li> <li> <code>return_last_version</code>             \u2013              <p>Returns the latest version associated with a given task.</p> </li> <li> <code>return_last_version_by_entity</code>             \u2013              <p>Returns the most recent version associated with a specific entity.</p> </li> <li> <code>return_my_tasks_filter</code>             \u2013              <p>Return filters for querying tasks assigned to the currently logged-in user.</p> </li> <li> <code>return_pack_folder</code>             \u2013              <p>Generate a pack folder name, optionally appending the current date.</p> </li> <li> <code>return_playlist_media</code>             \u2013              <p>Retrieve Version entities associated with a Playlist, including notes.</p> </li> <li> <code>return_task_notes</code>             \u2013              <p>Base method to create the note listing logic of a task,</p> </li> <li> <code>return_task_versions</code>             \u2013              <p>Base method to create the version listing logic of a task,</p> </li> <li> <code>return_tasks_by_entity</code>             \u2013              <p>Query ShotGrid for all tasks of a given entity type and wrap them as BaseTask objects.</p> </li> <li> <code>return_thumbnail_url</code>             \u2013              <p>Retrieve the thumbnail image URL for a specific entity.</p> </li> <li> <code>return_version_notes</code>             \u2013              <p>Base method to create the note listing logic of a playlist,</p> </li> <li> <code>return_versions_notes</code>             \u2013              <p>Base method to create the note listing logic of a playlist,</p> </li> <li> <code>task_long_to_short</code>             \u2013              <p>Returns the short alias for a given long task name.</p> </li> <li> <code>update_asset_task_fields_with_task_entities</code>             \u2013              <p>Update asset task fields based on associated ShotGrid task entities.</p> </li> <li> <code>upload_file</code>             \u2013              <p>Upload a local file to ShotGrid as a PublishedFile.</p> </li> <li> <code>upload_package</code>             \u2013              <p>Create and upload a zip package containing the specified files and their Maya dependencies.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>active_entities</code>               (<code>list[str]</code>)           \u2013            <p>Returns the list of active entity types the plugin supports.</p> </li> <li> <code>task_long_to_short_dict</code>               (<code>dict[str, str]</code>)           \u2013            <p>Returns the mapping of long task names to their short aliases.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.active_entities","title":"active_entities  <code>property</code>","text":"<pre><code>active_entities: list[str]\n</code></pre> <p>Returns the list of active entity types the plugin supports.</p> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>list[str]: List of supported entity types.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.task_long_to_short_dict","title":"task_long_to_short_dict  <code>property</code>","text":"<pre><code>task_long_to_short_dict: dict[str, str]\n</code></pre> <p>Returns the mapping of long task names to their short aliases.</p> <p>Returns:</p> <ul> <li> <code>dict[str, str]</code>           \u2013            <p>dict[str, str]: Dictionary of task name mappings.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.async_find","title":"async_find","text":"<pre><code>async_find(entity: str, filters: list[list[Any]] = [], fields: list[str] = [], page_size: int = 500) -&gt; list[dict[str, Any]]\n</code></pre> <p>Performs asynchronous paged queries on the ShotGrid API.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[dict[str, Any]]</code>           \u2013            <p>list[dict[str, Any]]: Flattened list of all retrieved results.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.async_find(entity)","title":"<code>entity</code>","text":"(<code>str</code>)           \u2013            <p>Entity type to query (e.g., 'Task').</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.async_find(filters)","title":"<code>filters</code>","text":"(<code>list[list[Any]]</code>, default:                   <code>[]</code> )           \u2013            <p>ShotGrid filter list.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.async_find(fields)","title":"<code>fields</code>","text":"(<code>list[str]</code>, default:                   <code>[]</code> )           \u2013            <p>Fields to retrieve.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.async_find(page_size)","title":"<code>page_size</code>","text":"(<code>int</code>, default:                   <code>500</code> )           \u2013            <p>Number of results per page.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.browse_note_data","title":"browse_note_data","text":"<pre><code>browse_note_data(note_id: int) -&gt; None\n</code></pre> <p>This method should be overriden according to each plugin. This opens the note in the plugin's database Args:     note_id (int): ID of the note to open.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.browse_task_data","title":"browse_task_data","text":"<pre><code>browse_task_data(task: BaseTask) -&gt; None\n</code></pre> <p>This method should be overriden according to each plugin. This opens the task in the plugin's database</p> <p>Parameters:</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.browse_task_data(task)","title":"<code>task</code>","text":"(<code>BaseTask</code>)           \u2013            <p>Task whose ShotGrid detail page should be opened.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.browse_version_data","title":"browse_version_data","text":"<pre><code>browse_version_data(version_id: int) -&gt; None\n</code></pre> <p>This method should be overriden according to each plugin. This opens the version in the plugin's database</p> <p>Parameters:</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.browse_version_data(version_id)","title":"<code>version_id</code>","text":"(<code>int</code>)           \u2013            <p>ID of the version to open.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.cache_data","title":"cache_data","text":"<pre><code>cache_data(file_name: str, data: list[dict[str, Any]]) -&gt; None\n</code></pre> <p>Stores task data in a cache file.</p> <p>Parameters:</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.cache_data(file_name)","title":"<code>file_name</code>","text":"(<code>str</code>)           \u2013            <p>Cache filename identifier.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.cache_data(data)","title":"<code>data</code>","text":"(<code>list[dict[str, Any]]</code>)           \u2013            <p>Data to cache.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.check_file_is_uploaded","title":"check_file_is_uploaded","text":"<pre><code>check_file_is_uploaded(file: Path) -&gt; bool\n</code></pre> <p>Check if a given file name has an associated PublishedFile in ShotGrid.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if a PublishedFile with the same code exists.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.check_file_is_uploaded(file)","title":"<code>file</code>","text":"(<code>Path</code>)           \u2013            <p>The local file to check.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.check_version_is_published","title":"check_version_is_published","text":"<pre><code>check_version_is_published(version: Path) -&gt; bool\n</code></pre> <p>Check if a given version file name has already been published to ShotGrid.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if a Version entity with the same code exists.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.check_version_is_published(version)","title":"<code>version</code>","text":"(<code>Path</code>)           \u2013            <p>Path to the version file.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.create_note","title":"create_note","text":"<pre><code>create_note(links: list[Any] = [], status: str = 'opn', body: str = '', subject: str = '', tasks: list[BaseTask] = [], to: list[Any] = [], author: dict[str, Any] = {}, **kwargs) -&gt; None\n</code></pre> <p>Create a new Note entity in ShotGrid.</p> <p>Parameters:</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.create_note(links)","title":"<code>links</code>","text":"(<code>list[Any]</code>, default:                   <code>[]</code> )           \u2013            <p>List of linked entities.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.create_note(status)","title":"<code>status</code>","text":"(<code>str</code>, default:                   <code>'opn'</code> )           \u2013            <p>Note status.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.create_note(body)","title":"<code>body</code>","text":"(<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Body content.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.create_note(subject)","title":"<code>subject</code>","text":"(<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Subject line.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.create_note(tasks)","title":"<code>tasks</code>","text":"(<code>list[Any]</code>, default:                   <code>[]</code> )           \u2013            <p>Associated task entities.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.create_note(to)","title":"<code>to</code>","text":"(<code>list[Any]</code>, default:                   <code>[]</code> )           \u2013            <p>Users addressed in the note.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.create_note(author)","title":"<code>author</code>","text":"(<code>dict[str, Any]</code>, default:                   <code>{}</code> )           \u2013            <p>User entity of the note author.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.create_note(**kwargs)","title":"<code>**kwargs</code>","text":"\u2013            <p>Additional ShotGrid fields.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.create_pack","title":"create_pack","text":"<pre><code>create_pack(pack_type: str, ep: str) -&gt; Generator[str, None, None]\n</code></pre> <p>Looks for versions that matches the data passed as args, and adds them to a given folder.</p> <p>Parameters:</p> <p>Yields:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>Names of copied files.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.create_pack(pack_type)","title":"<code>pack_type</code>","text":"(<code>str</code>)           \u2013            <p>Type of pack to create.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.create_pack(ep)","title":"<code>ep</code>","text":"(<code>str</code>)           \u2013            <p>Episode identifier.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.create_pack_from_dialog","title":"create_pack_from_dialog","text":"<pre><code>create_pack_from_dialog(p: Path, versions: list[dict[str, Any]], extensions: list[str]) -&gt; Generator[str, None, None]\n</code></pre> <p>Pack selected version files based on user-selected filters.</p> <p>Parameters:</p> <p>Yields:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>File names of the packed assets.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.create_pack_from_dialog(p)","title":"<code>p</code>","text":"(<code>Path</code>)           \u2013            <p>Target folder path for the pack.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.create_pack_from_dialog(versions)","title":"<code>versions</code>","text":"(<code>list[dict[str, Any]]</code>)           \u2013            <p>List of version dictionaries to pack.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.create_pack_from_dialog(extensions)","title":"<code>extensions</code>","text":"(<code>list[str]</code>)           \u2013            <p>File extensions to include.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.create_shot","title":"create_shot","text":"<pre><code>create_shot(shot_data: dict[str, Any], task_name: Optional[str] = None) -&gt; dict[str, Any]\n</code></pre> <p>Create or update a Shot entity and upload an associated version if applicable.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>           \u2013            <p>dict[str, Any]: The created or updated Shot entity.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.create_shot(shot_data)","title":"<code>shot_data</code>","text":"(<code>dict[str, Any]</code>)           \u2013            <p>Dictionary with shot data.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.create_shot(task_name)","title":"<code>task_name</code>","text":"(<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>Optional name of the task for thumbnail association.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.create_thumbnail","title":"create_thumbnail","text":"<pre><code>create_thumbnail(task: BaseTask) -&gt; Optional[Path]\n</code></pre> <p>Generate and set a thumbnail for the given task.</p> <p>Attempts to generate a thumbnail from the latest .jpg file in the task directory. If not found, it falls back to downloading from ShotGrid.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Optional[Path]</code>           \u2013            <p>Optional[Path]: Path to the generated thumbnail or None if failed.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.create_thumbnail(task)","title":"<code>task</code>","text":"(<code>BaseTask</code>)           \u2013            <p>The task for which to create the thumbnail.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.dowload_last_file_from_name","title":"dowload_last_file_from_name","text":"<pre><code>dowload_last_file_from_name(name: str, path: str) -&gt; Optional[Path]\n</code></pre> <p>Download the most recent published file whose code contains the given name.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Optional[Path]</code>           \u2013            <p>Optional[Path]: Local path of the downloaded file if successful, otherwise None.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.dowload_last_file_from_name(name)","title":"<code>name</code>","text":"(<code>str</code>)           \u2013            <p>Name substring to match against the PublishedFile code.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.dowload_last_file_from_name(path)","title":"<code>path</code>","text":"(<code>str</code>)           \u2013            <p>Destination folder path where the file will be downloaded.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.dowload_last_file_from_task","title":"dowload_last_file_from_task","text":"<pre><code>dowload_last_file_from_task(task: BaseTask, path: Optional[Union[str, Path]] = None) -&gt; Optional[Path]\n</code></pre> <p>Download the last file published for a given task.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Optional[Path]</code>           \u2013            <p>Optional[Path]: File path if downloaded, else None.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.dowload_last_file_from_task(task)","title":"<code>task</code>","text":"(<code>BaseTask</code>)           \u2013            <p>Task to query.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.dowload_last_file_from_task(path)","title":"<code>path</code>","text":"(<code>Optional[Union[str, Path]]</code>, default:                   <code>None</code> )           \u2013            <p>Destination path.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.download_file","title":"download_file","text":"<pre><code>download_file(id: int, path: Path) -&gt; Union[Path, bool]\n</code></pre> <p>Download a PublishedFile from ShotGrid by ID.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Union[Path, bool]</code>           \u2013            <p>Union[Path, bool]: Local path to the file, or False if failed.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.download_file(id)","title":"<code>id</code>","text":"(<code>int</code>)           \u2013            <p>ShotGrid PublishedFile ID.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.download_file(path)","title":"<code>path</code>","text":"(<code>Path</code>)           \u2013            <p>Directory to save the file to.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.download_last_version_from_entity","title":"download_last_version_from_entity","text":"<pre><code>download_last_version_from_entity(task: str, id: int, path: Path) -&gt; bool\n</code></pre> <p>Download the last uploaded MP4 movie associated with a specific entity.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if download was successful, otherwise False.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.download_last_version_from_entity(task)","title":"<code>task</code>","text":"(<code>str</code>)           \u2013            <p>Unused placeholder argument.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.download_last_version_from_entity(id)","title":"<code>id</code>","text":"(<code>int</code>)           \u2013            <p>Entity ID.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.download_last_version_from_entity(path)","title":"<code>path</code>","text":"(<code>Path</code>)           \u2013            <p>Destination file path.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.download_package","title":"download_package","text":"<pre><code>download_package(package: Union[str, BaseTask]) -&gt; Optional[list[Path]]\n</code></pre> <p>Download a package from ShotGrid by task or package name and extract it.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Optional[list[Path]]</code>           \u2013            <p>Optional[list[Path]]: List of extracted files or None.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.download_package(package)","title":"<code>package</code>","text":"(<code>Union[str, BaseTask]</code>)           \u2013            <p>Task or package name to download.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.download_thumbnail_from_sg","title":"download_thumbnail_from_sg","text":"<pre><code>download_thumbnail_from_sg(entity_type: str, id: int, path: Path) -&gt; bool\n</code></pre> <p>Download a thumbnail image from a ShotGrid entity.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if successful, False otherwise.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.download_thumbnail_from_sg(entity_type)","title":"<code>entity_type</code>","text":"(<code>str</code>)           \u2013            <p>Type of entity (e.g., 'Task').</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.download_thumbnail_from_sg(id)","title":"<code>id</code>","text":"(<code>int</code>)           \u2013            <p>ID of the entity.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.download_thumbnail_from_sg(path)","title":"<code>path</code>","text":"(<code>Path</code>)           \u2013            <p>Path where the image should be saved.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.download_version","title":"download_version","text":"<pre><code>download_version(id: int, path: Path) -&gt; Union[Path, bool]\n</code></pre> <p>Download the movie file from a version.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Union[Path, bool]</code>           \u2013            <p>Union[Path, bool]: Path to downloaded file or False if unsuccessful.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.download_version(id)","title":"<code>id</code>","text":"(<code>int</code>)           \u2013            <p>ShotGrid Version ID.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.download_version(path)","title":"<code>path</code>","text":"(<code>Path</code>)           \u2013            <p>Directory to store the downloaded file.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.download_versions_from_sg","title":"download_versions_from_sg","text":"<pre><code>download_versions_from_sg() -&gt; None\n</code></pre> <p>Download all version movie files (sg_uploaded_movie) for selected tasks.</p> <p>For each version in each selected task, this function saves the movie to the preview location if it doesn't already exist.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.generate_package_name","title":"generate_package_name","text":"<pre><code>generate_package_name(task: BaseTask) -&gt; str\n</code></pre> <p>Generate a unique package name based on task and current user.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>A filename-safe package name.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.generate_package_name(task)","title":"<code>task</code>","text":"(<code>BaseTask</code>)           \u2013            <p>The task to generate the package name for.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.get_all_tasks_data","title":"get_all_tasks_data","text":"<pre><code>get_all_tasks_data(return_object: dict[str, Any], callback: Optional[Callable[[], None]] = None, force_no_cache: bool = False, cache_data: bool = True, *args: Any, **kwargs: Any) -&gt; None\n</code></pre> <p>Retrieve all tasks for the specified entity type, handle caching, and invoke callback.</p> <p>Parameters:</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.get_all_tasks_data(return_object)","title":"<code>return_object</code>","text":"(<code>dict[str, Any]</code>)           \u2013            <p>Dict to populate with <code>return_object[\"results\"] = (tasks, headers)</code>.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.get_all_tasks_data(callback)","title":"<code>callback</code>","text":"(<code>Optional[Callable[[], None]]</code>, default:                   <code>None</code> )           \u2013            <p>Function to call once tasks are loaded.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.get_all_tasks_data(force_no_cache)","title":"<code>force_no_cache</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, ignore existing cache.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.get_all_tasks_data(cache_data)","title":"<code>cache_data</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, update the local cache with new results.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.get_all_tasks_data(*args)","title":"<code>*args</code>","text":"(<code>Any</code>, default:                   <code>()</code> )           \u2013            <p>Additional positional arguments.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.get_all_tasks_data(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Keyword args, expects 'sg_entity_type' key.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.parse_edl_file","title":"parse_edl_file","text":"<pre><code>parse_edl_file(source_edl: Path, source_video: Path, episode_name: Optional[str] = None, edl_target_task: Optional[str] = None, task: Optional[BaseTask] = None) -&gt; Generator[dict[str, Any], None, None]\n</code></pre> <p>Parse an EDL file and yield shot metadata for creation or update.</p> <p>Parameters:</p> <p>Yields:</p> <ul> <li> <code>dict[str, Any]</code>           \u2013            <p>Generator[dict[str, Any], None, None]: Metadata for each parsed shot.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.parse_edl_file(source_edl)","title":"<code>source_edl</code>","text":"(<code>Path</code>)           \u2013            <p>Path to the source EDL file.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.parse_edl_file(source_video)","title":"<code>source_video</code>","text":"(<code>Path</code>)           \u2013            <p>Path to the source video file.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.parse_edl_file(episode_name)","title":"<code>episode_name</code>","text":"(<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>Name of the episode to associate with the EDL.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.parse_edl_file(edl_target_task)","title":"<code>edl_target_task</code>","text":"(<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>Name of the EDL-related task.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.parse_edl_file(task)","title":"<code>task</code>","text":"(<code>Optional[BaseTask]</code>, default:                   <code>None</code> )           \u2013            <p>Optional BaseTask context fallback.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.publish_file","title":"publish_file","text":"<pre><code>publish_file(file: Path, version: Optional[dict[str, Any]] = None, task: Optional[BaseTask] = None, description: str = '') -&gt; dict[str, Union[bool, str, None]]\n</code></pre> <p>Upload a file as a PublishedFile entity to ShotGrid.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>dict[str, Union[bool, str, None]]</code>           \u2013            <p>dict[str, Union[bool, str, None]]: Dictionary containing upload status, message and any error.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.publish_file(file)","title":"<code>file</code>","text":"(<code>Path</code>)           \u2013            <p>The local file path to upload.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.publish_file(version)","title":"<code>version</code>","text":"(<code>Optional[dict[str, Any]]</code>, default:                   <code>None</code> )           \u2013            <p>Version entity to link with this PublishedFile.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.publish_file(task)","title":"<code>task</code>","text":"(<code>Optional[BaseTask]</code>, default:                   <code>None</code> )           \u2013            <p>Task associated with the file.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.publish_file(description)","title":"<code>description</code>","text":"(<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Description of the upload.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.publish_last_version","title":"publish_last_version","text":"<pre><code>publish_last_version(task: Optional[BaseTask] = None) -&gt; bool\n</code></pre> <p>Publish the last version file for the specified or last-clicked task.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if publishing succeeds, otherwise False.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.publish_last_version(task)","title":"<code>task</code>","text":"(<code>Optional[BaseTask]</code>, default:                   <code>None</code> )           \u2013            <p>Task to publish. Defaults to last clicked.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.publish_timelog","title":"publish_timelog","text":"<pre><code>publish_timelog(task: BaseTask, duration: int) -&gt; dict[str, Union[bool, str, None]]\n</code></pre> <p>Publish a timelog entry in ShotGrid for the given task and duration.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>dict[str, Union[bool, str, None]]</code>           \u2013            <p>dict[str, Union[bool, str, None]]: A result dict with status, message, and error.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.publish_timelog(task)","title":"<code>task</code>","text":"(<code>BaseTask</code>)           \u2013            <p>The task for which the timelog will be created.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.publish_timelog(duration)","title":"<code>duration</code>","text":"(<code>int</code>)           \u2013            <p>Duration in minutes to be logged.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.publish_version","title":"publish_version","text":"<pre><code>publish_version(task: BaseTask, version: Path, description: str = '') -&gt; dict[str, Union[bool, str, None, dict[str, Any]]]\n</code></pre> <p>Method for creating the logic for publishing, the return object should be a dictionary with the following structure:</p> <p>{     \"success\" : bool,     \"message\" : str,     \"error\" : str |None # Exception like error     \"entity\" : dict |None }</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>dict[str, Union[bool, str, None, dict[str, Any]]]</code>           \u2013            <p>dict[str, Union[bool, str, None, dict[str, Any]]]: A result dict with status, message, error (if any), and version entity.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.publish_version(task)","title":"<code>task</code>","text":"(<code>BaseTask</code>)           \u2013            <p>Task associated with the version.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.publish_version(version)","title":"<code>version</code>","text":"(<code>Path</code>)           \u2013            <p>Local path to the video file to upload.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.publish_version(description)","title":"<code>description</code>","text":"(<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Optional description of the version.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.receive_config_data_from_app","title":"receive_config_data_from_app","text":"<pre><code>receive_config_data_from_app(*args, **kwargs) -&gt; None\n</code></pre> <p>Receives entity-type configuration data from an external application.</p> <p>Parameters:</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.receive_config_data_from_app(*args)","title":"<code>*args</code>","text":"\u2013            <p>Positional arguments (unused).</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.receive_config_data_from_app(**kwargs)","title":"<code>**kwargs</code>","text":"\u2013            <p>Keyword arguments containing 'sg_active_entity'.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.retrieve_cached","title":"retrieve_cached","text":"<pre><code>retrieve_cached(link_type: str) -&gt; tuple[list[dict[str, Any]], Optional[datetime], bool]\n</code></pre> <p>Attempts to load cached task data for the given link type.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>tuple[list[dict[str, Any]], Optional[datetime], bool]</code>           \u2013            <p>tuple[list[dict[str, Any]], Optional[datetime], bool]: Cached data, last modified date, and success flag.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.retrieve_cached(link_type)","title":"<code>link_type</code>","text":"(<code>str</code>)           \u2013            <p>The ShotGrid entity type.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.retrieve_latests_tasks","title":"retrieve_latests_tasks","text":"<pre><code>retrieve_latests_tasks(link_type: str, sg_filters: list[list[Any]], force_no_cache: bool) -&gt; list[dict[str, Any]]\n</code></pre> <p>Uses the cache to get its date so that only the tasks that were updated after the last cache are retrieved. These tasks are merged with the cache.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[dict[str, Any]]</code>           \u2013            <p>list[dict[str, Any]]: Combined list of new and (if not forced) cached task dicts.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.retrieve_latests_tasks(link_type)","title":"<code>link_type</code>","text":"(<code>str</code>)           \u2013            <p>The entity type to query (e.g., \"Shot\").</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.retrieve_latests_tasks(sg_filters)","title":"<code>sg_filters</code>","text":"(<code>list[list[Any]]</code>)           \u2013            <p>ShotGrid filter definitions.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.retrieve_latests_tasks(force_no_cache)","title":"<code>force_no_cache</code>","text":"(<code>bool</code>)           \u2013            <p>If True, bypass local cache entirely.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.return_all_assets","title":"return_all_assets","text":"<pre><code>return_all_assets() -&gt; dict[str, dict[str, Any]]\n</code></pre> <p>Retrieve all Asset entities for the configured project.</p> <p>Returns:</p> <ul> <li> <code>dict[str, dict[str, Any]]</code>           \u2013            <p>dict[str, dict[str, Any]]: Mapping asset code to its SG entity dict.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.return_all_episodes","title":"return_all_episodes","text":"<pre><code>return_all_episodes() -&gt; dict[str, dict[str, Any]]\n</code></pre> <p>Retrieve all Episode entities for the configured project.</p> <p>Returns:</p> <ul> <li> <code>dict[str, dict[str, Any]]</code>           \u2013            <p>dict[str, dict[str, Any]]: Mapping episode code to its SG entity dict.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.return_all_packages","title":"return_all_packages","text":"<pre><code>return_all_packages(filters: Optional[list[list[Any]]] = None, fields: Optional[list[str]] = None) -&gt; list[dict[str, Any]]\n</code></pre> <p>Retrieve all PublishedFile (package) entities matching optional filters.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[dict[str, Any]]</code>           \u2013            <p>list[dict[str, Any]]: List of PublishedFile entity dicts.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.return_all_packages(filters)","title":"<code>filters</code>","text":"(<code>Optional[list[list[Any]]]</code>, default:                   <code>None</code> )           \u2013            <p>ShotGrid filters to apply.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.return_all_packages(fields)","title":"<code>fields</code>","text":"(<code>Optional[list[str]]</code>, default:                   <code>None</code> )           \u2013            <p>Fields to include in results.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.return_all_playlists","title":"return_all_playlists","text":"<pre><code>return_all_playlists() -&gt; list[dict[str, Any]]\n</code></pre> <p>Retrieve all Playlist entities for the configured project.</p> <p>Returns:</p> <ul> <li> <code>list[dict[str, Any]]</code>           \u2013            <p>list[dict[str, Any]]: List of Playlist entity dicts.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.return_all_sequences","title":"return_all_sequences","text":"<pre><code>return_all_sequences() -&gt; dict[str, dict[str, Any]]\n</code></pre> <p>Retrieve all Sequence entities for the configured project.</p> <p>Returns:</p> <ul> <li> <code>dict[str, dict[str, Any]]</code>           \u2013            <p>dict[str, dict[str, Any]]: Mapping sequence code to its SG entity dict.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.return_all_shots","title":"return_all_shots","text":"<pre><code>return_all_shots(filters: list[list[Any]] = []) -&gt; dict[str, dict[str, Any]]\n</code></pre> <p>Retrieve all Shot entities, optionally filtered, for the project.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>dict[str, dict[str, Any]]</code>           \u2013            <p>dict[str, dict[str, Any]]: Mapping shot code to its SG entity dict.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.return_all_shots(filters)","title":"<code>filters</code>","text":"(<code>list[list[Any]]</code>, default:                   <code>[]</code> )           \u2013            <p>Additional filter rules.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.return_all_versions","title":"return_all_versions","text":"<pre><code>return_all_versions(filters: Optional[list[list[Any]]] = None, fields: Optional[list[str]] = None) -&gt; list[dict[str, Any]]\n</code></pre> <p>Retrieve all Version entities matching optional filters.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[dict[str, Any]]</code>           \u2013            <p>list[dict[str, Any]]: List of Version entity dicts.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.return_all_versions(filters)","title":"<code>filters</code>","text":"(<code>Optional[list[list[Any]]]</code>, default:                   <code>None</code> )           \u2013            <p>ShotGrid filters to apply.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.return_all_versions(fields)","title":"<code>fields</code>","text":"(<code>Optional[list[str]]</code>, default:                   <code>None</code> )           \u2013            <p>Fields to include in results.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.return_custom_artist_entity","title":"return_custom_artist_entity","text":"<pre><code>return_custom_artist_entity() -&gt; Union[dict[str, Any], bool]\n</code></pre> <p>Return the custom artist entity linked to the current user.</p> <p>Returns:</p> <ul> <li> <code>Union[dict[str, Any], bool]</code>           \u2013            <p>Union[dict[str, Any], bool]: ShotGrid entity dict or False if not found/configured.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.return_data_to_show","title":"return_data_to_show","text":"<pre><code>return_data_to_show(sg_task: dict[str, Any], link_type: str, thumbnail: BaseThumbnail, assignees: list[str], tags: str, asset_type: str, episodes: str, created_for_episode: Optional[str], cut_in: Any, cut_out: Any, cut_duration: Any, sequence: Any, episode: Any) -&gt; list[dict[str, Any]]\n</code></pre> <p>Format a ShotGrid task into a list of UI\u2010ready rows matching headers.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[dict[str, Any]]</code>           \u2013            <p>list[dict[str, Any]]: List of dicts with keys \"text\", \"icon\", \"thumbnail\", \"background_color\".</p> </li> </ul>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.return_data_to_show(sg_task)","title":"<code>sg_task</code>","text":"(<code>dict[str, Any]</code>)           \u2013            <p>Raw ShotGrid Task entity.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.return_data_to_show(link_type)","title":"<code>link_type</code>","text":"(<code>str</code>)           \u2013            <p>Entity type of the task (e.g., \"Shot\").</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.return_data_to_show(thumbnail)","title":"<code>thumbnail</code>","text":"(<code>BaseThumbnail</code>)           \u2013            <p>Thumbnail object for display.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.return_data_to_show(assignees)","title":"<code>assignees</code>","text":"(<code>list[str]</code>)           \u2013            <p>Names of assigned artists.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.return_data_to_show(tags)","title":"<code>tags</code>","text":"(<code>str</code>)           \u2013            <p>Space\u2010separated tag names.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.return_data_to_show(asset_type)","title":"<code>asset_type</code>","text":"(<code>str</code>)           \u2013            <p>Asset type code.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.return_data_to_show(episodes)","title":"<code>episodes</code>","text":"(<code>str</code>)           \u2013            <p>Episode codes.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.return_data_to_show(created_for_episode)","title":"<code>created_for_episode</code>","text":"(<code>Optional[str]</code>)           \u2013            <p>Original episode code.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.return_data_to_show(cut_in)","title":"<code>cut_in</code>","text":"(<code>Any</code>)           \u2013            <p>Cut in frame or None.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.return_data_to_show(cut_out)","title":"<code>cut_out</code>","text":"(<code>Any</code>)           \u2013            <p>Cut out frame or None.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.return_data_to_show(cut_duration)","title":"<code>cut_duration</code>","text":"(<code>Any</code>)           \u2013            <p>Duration in frames or None.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.return_data_to_show(sequence)","title":"<code>sequence</code>","text":"(<code>Any</code>)           \u2013            <p>Sequence code or None.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.return_data_to_show(episode)","title":"<code>episode</code>","text":"(<code>Any</code>)           \u2013            <p>Episode code or None.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.return_entity_description","title":"return_entity_description","text":"<pre><code>return_entity_description(task: BaseTask, force_stop: Callable[[], bool] = lambda: False) -&gt; str\n</code></pre> <p>Fetch the description of the entity linked to a given task.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>The entity's description, or empty string if not found/aborted.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.return_entity_description(task)","title":"<code>task</code>","text":"(<code>BaseTask</code>)           \u2013            <p>Task whose parent entity description to retrieve.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.return_entity_description(force_stop)","title":"<code>force_stop</code>","text":"(<code>Callable[[], bool]</code>, default:                   <code>lambda: False</code> )           \u2013            <p>If True at any point, aborts and returns empty string.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.return_fields_from_entity_type","title":"return_fields_from_entity_type","text":"<pre><code>return_fields_from_entity_type(entity_type: str) -&gt; list[str]\n</code></pre> <p>Generate the list of ShotGrid fields to request based on entity type.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>list[str]: Unique list of field names to retrieve for the given entity.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.return_fields_from_entity_type(entity_type)","title":"<code>entity_type</code>","text":"(<code>str</code>)           \u2013            <p>The ShotGrid entity type (e.g., \"Shot\" or \"Asset\").</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.return_last_version","title":"return_last_version","text":"<pre><code>return_last_version(task_id: int) -&gt; Optional[dict[str, Any]]\n</code></pre> <p>Returns the latest version associated with a given task.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Optional[dict[str, Any]]</code>           \u2013            <p>Optional[dict[str, Any]]: Latest version dictionary or None.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.return_last_version(task_id)","title":"<code>task_id</code>","text":"(<code>int</code>)           \u2013            <p>ID of the task.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.return_last_version_by_entity","title":"return_last_version_by_entity","text":"<pre><code>return_last_version_by_entity(entity: dict[str, Any], fields: list[str] = []) -&gt; Optional[dict[str, Any]]\n</code></pre> <p>Returns the most recent version associated with a specific entity.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Optional[dict[str, Any]]</code>           \u2013            <p>Optional[dict[str, Any]]: Latest version dictionary or None.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.return_last_version_by_entity(entity)","title":"<code>entity</code>","text":"(<code>dict[str, Any]</code>)           \u2013            <p>ShotGrid entity dictionary.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.return_last_version_by_entity(fields)","title":"<code>fields</code>","text":"(<code>list[str]</code>, default:                   <code>[]</code> )           \u2013            <p>Additional fields to include in the query.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.return_my_tasks_filter","title":"return_my_tasks_filter","text":"<pre><code>return_my_tasks_filter() -&gt; list[list[Any]]\n</code></pre> <p>Return filters for querying tasks assigned to the currently logged-in user.</p> <p>Returns:</p> <ul> <li> <code>list[list[Any]]</code>           \u2013            <p>list[list[Any]]: ShotGrid filter for user's tasks.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.return_pack_folder","title":"return_pack_folder  <code>staticmethod</code>","text":"<pre><code>return_pack_folder(folder_name: str, add_date: bool = False) -&gt; str\n</code></pre> <p>Generate a pack folder name, optionally appending the current date.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>Final folder name.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.return_pack_folder(folder_name)","title":"<code>folder_name</code>","text":"(<code>str</code>)           \u2013            <p>Base name of the folder.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.return_pack_folder(add_date)","title":"<code>add_date</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, appends current date in YYYYMMDD format.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.return_playlist_media","title":"return_playlist_media","text":"<pre><code>return_playlist_media(playlist_id: int, fields: Optional[list[str]] = None) -&gt; list[dict[str, Any]]\n</code></pre> <p>Retrieve Version entities associated with a Playlist, including notes.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[dict[str, Any]]</code>           \u2013            <p>list[dict[str, Any]]: List of Version entity dicts in the playlist.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.return_playlist_media(playlist_id)","title":"<code>playlist_id</code>","text":"(<code>int</code>)           \u2013            <p>ID of the Playlist entity.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.return_playlist_media(fields)","title":"<code>fields</code>","text":"(<code>Optional[list[str]]</code>, default:                   <code>None</code> )           \u2013            <p>Additional fields to include.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.return_task_notes","title":"return_task_notes","text":"<pre><code>return_task_notes(task: BaseTask, force_stop: Callable[[], bool] = lambda: False) -&gt; list[dict[str, Any]]\n</code></pre> <p>Base method to create the note listing logic of a task, the returned object must be a list with the following structure:</p> <p>[{     \"content\" : str,     \"created_by\" : str  or None,     \"created_at\" : str or None,     \"attachments\" : dict[\"url\",\"bytes\" or \"url\"],     \"url\" : str     \"reply\" : list[dict] }]</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[dict[str, Any]]</code>           \u2013            <p>list[dict[str, Any]]: List of notes including content, author, timestamp,</p> </li> <li> <code>list[dict[str, Any]]</code>           \u2013            <p>attachments, replies, and direct ShotGrid URLs.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.return_task_notes(task)","title":"<code>task</code>","text":"(<code>BaseTask</code>)           \u2013            <p>The task for which to retrieve notes.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.return_task_notes(force_stop)","title":"<code>force_stop</code>","text":"(<code>Callable[[], bool]</code>, default:                   <code>lambda: False</code> )           \u2013            <p>If True, aborts and returns empty list.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.return_task_versions","title":"return_task_versions","text":"<pre><code>return_task_versions(task: BaseTask) -&gt; list[list[Any]]\n</code></pre> <p>Base method to create the version listing logic of a task, the returned object must be a list with the following structure:</p> <p>[{     \"content\" : str,     \"created_by\" : str  or None,     \"created_at\" : str or None,     \"attachments\" : dict[\"url\",\"bytes\" or \"url\"],     \"url\" : str     \"reply\" : list[dict] }]</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[list[Any]]</code>           \u2013            <p>list[list[Any]]: A list of version details, each item containing: [version_id, thumbnail_url, version_code, user_name, status_code]</p> </li> </ul>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.return_task_versions(task)","title":"<code>task</code>","text":"(<code>BaseTask</code>)           \u2013            <p>The task entity to query versions for.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.return_tasks_by_entity","title":"return_tasks_by_entity","text":"<pre><code>return_tasks_by_entity(link_type: str, force_no_cache: bool = False, filters: list[list[Any]] = [], cache_data: bool = True) -&gt; Optional[list[BaseTask]]\n</code></pre> <p>Query ShotGrid for all tasks of a given entity type and wrap them as BaseTask objects.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Optional[list[BaseTask]]</code>           \u2013            <p>Optional[list[BaseTask]]: A list of BaseTask instances, or None on failure.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.return_tasks_by_entity(link_type)","title":"<code>link_type</code>","text":"(<code>str</code>)           \u2013            <p>The entity type code (e.g., \"Asset\", \"Shot\").</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.return_tasks_by_entity(force_no_cache)","title":"<code>force_no_cache</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, bypass the cache layer.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.return_tasks_by_entity(filters)","title":"<code>filters</code>","text":"(<code>list[list[Any]]</code>, default:                   <code>[]</code> )           \u2013            <p>Additional ShotGrid filters.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.return_tasks_by_entity(cache_data)","title":"<code>cache_data</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, save the raw SG results to cache.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.return_thumbnail_url","title":"return_thumbnail_url","text":"<pre><code>return_thumbnail_url(entity_type: str, id: int) -&gt; Optional[str]\n</code></pre> <p>Retrieve the thumbnail image URL for a specific entity.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Optional[str]</code>           \u2013            <p>Optional[str]: URL of the thumbnail image or None if not found.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.return_thumbnail_url(entity_type)","title":"<code>entity_type</code>","text":"(<code>str</code>)           \u2013            <p>The type of entity (e.g., 'Task', 'Asset').</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.return_thumbnail_url(id)","title":"<code>id</code>","text":"(<code>int</code>)           \u2013            <p>ID of the entity.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.return_version_notes","title":"return_version_notes","text":"<pre><code>return_version_notes(version: dict[str, Any], download_attachments: Union[Path, bool] = False) -&gt; list[dict[str, Any]]\n</code></pre> <p>Base method to create the note listing logic of a playlist, the returned object must be a list with the following structure:</p> <p>[{     \"content\" : str,     \"created_by\" : str  or None,     \"created_at\" : str or None,     \"attachments\" : dict[\"url\",\"bytes\"],     \"url\" : str }]</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[dict[str, Any]]</code>           \u2013            <p>list[dict[str, Any]]: The same version dict with 'attachments' populated.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.return_version_notes(version)","title":"<code>version</code>","text":"(<code>dict[str, Any]</code>)           \u2013            <p>A ShotGrid version dictionary.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.return_version_notes(download_attachments)","title":"<code>download_attachments</code>","text":"(<code>Union[Path, bool]</code>, default:                   <code>False</code> )           \u2013            <p>Path to download files to.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.return_versions_notes","title":"return_versions_notes","text":"<pre><code>return_versions_notes(list_version: list[dict[str, Any]], download_attachments: Union[Path, bool] = False) -&gt; list[dict[str, Any]]\n</code></pre> <p>Base method to create the note listing logic of a playlist, the returned object must be a list with the following structure:</p> <p>[{     \"content\" : str,     \"created_by\" : str  or None,     \"created_at\" : str or None,     \"attachments\" : dict[\"url\",\"bytes\"],     \"url\" : str }]</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[dict[str, Any]]</code>           \u2013            <p>list[dict[str, Any]]: Updated version dictionaries with note attachments.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.return_versions_notes(list_version)","title":"<code>list_version</code>","text":"(<code>list[dict[str, Any]]</code>)           \u2013            <p>Versions to extract notes from.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.return_versions_notes(download_attachments)","title":"<code>download_attachments</code>","text":"(<code>Union[Path, bool]</code>, default:                   <code>False</code> )           \u2013            <p>Destination path to download attachments or False.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.task_long_to_short","title":"task_long_to_short","text":"<pre><code>task_long_to_short(task_name: str) -&gt; str\n</code></pre> <p>Returns the short alias for a given long task name.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>Shortened task name.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Exception</code>             \u2013            <p>If task name is not found in the dictionary.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.task_long_to_short(task_name)","title":"<code>task_name</code>","text":"(<code>str</code>)           \u2013            <p>Full name of the task.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.update_asset_task_fields_with_task_entities","title":"update_asset_task_fields_with_task_entities","text":"<pre><code>update_asset_task_fields_with_task_entities(additional_filters: Optional[list[Any]] = None) -&gt; None\n</code></pre> <p>Update asset task fields based on associated ShotGrid task entities.</p> <p>Parameters:</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.update_asset_task_fields_with_task_entities(additional_filters)","title":"<code>additional_filters</code>","text":"(<code>Optional[list[Any]]</code>, default:                   <code>None</code> )           \u2013            <p>Additional filters for the ShotGrid query.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.upload_file","title":"upload_file","text":"<pre><code>upload_file(file: Path, task: Optional[BaseTask] = None, description: str = '') -&gt; dict[str, Any]\n</code></pre> <p>Upload a local file to ShotGrid as a PublishedFile.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>           \u2013            <p>dict[str, Any]: A result dictionary indicating success, message, and error if any.</p> </li> </ul>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.upload_file(file)","title":"<code>file</code>","text":"(<code>Path</code>)           \u2013            <p>The file to upload.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.upload_file(task)","title":"<code>task</code>","text":"(<code>Optional[BaseTask]</code>, default:                   <code>None</code> )           \u2013            <p>The task associated with the file.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.upload_file(description)","title":"<code>description</code>","text":"(<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Optional description for the upload.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.upload_package","title":"upload_package","text":"<pre><code>upload_package(list_files: list[Path], package_name: str, task: Optional[BaseTask] = None) -&gt; Iterator[tuple[int, str]]\n</code></pre> <p>Create and upload a zip package containing the specified files and their Maya dependencies.</p> <p>This function yields progress updates at different stages of packaging and uploading: - 0\u201310%: Preparing files - 10\u201350%: Resolving Maya dependencies - 70\u201399%: Uploading the package to ShotGrid</p> <p>Parameters:</p> <p>Yields:</p> <ul> <li> <code>tuple[int, str]</code>           \u2013            <p>Iterator[tuple[int, str]]: Tuples of (progress percentage, status message).</p> </li> </ul>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.upload_package(list_files)","title":"<code>list_files</code>","text":"(<code>list[Path]</code>)           \u2013            <p>List of files to include in the package.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.upload_package(package_name)","title":"<code>package_name</code>","text":"(<code>str</code>)           \u2013            <p>The name for the zip archive to be created.</p>"},{"location":"dev/task_schema/plugins/shotgrid_plugin/#plugins.shotgrid_plugin.ShotgridPlugin.upload_package(task)","title":"<code>task</code>","text":"(<code>Optional[BaseTask]</code>, default:                   <code>None</code> )           \u2013            <p>Optional task context to associate the upload with.</p>"},{"location":"dev/task_schema/tests/test_anniecarola_plugin/","title":"test_anniecarola_plugin","text":""},{"location":"dev/task_schema/tests/test_anniecarola_plugin/#test_anniecarola_plugin","title":"<code>test_anniecarola_plugin</code>","text":""},{"location":"dev/task_schema/tests/test_anniecarola_plugin/#tests.test_anniecarola_plugin","title":"test_anniecarola_plugin","text":"<p>Classes:</p> <ul> <li> <code>AnniecarolaPluginTests</code>           \u2013            <p>This class will run different tests to</p> </li> </ul>"},{"location":"dev/task_schema/tests/test_anniecarola_plugin/#tests.test_anniecarola_plugin.AnniecarolaPluginTests","title":"AnniecarolaPluginTests","text":"<p>This class will run different tests to check that the class ShotgridPlugin works as it is intended to work.</p> <p>Methods:</p> <ul> <li> <code>setUpClass</code>             \u2013              <p>Looks for errors while instantiating,</p> </li> </ul>"},{"location":"dev/task_schema/tests/test_anniecarola_plugin/#tests.test_anniecarola_plugin.AnniecarolaPluginTests.setUpClass","title":"setUpClass  <code>classmethod</code>","text":"<pre><code>setUpClass()\n</code></pre> <p>Looks for errors while instantiating, mostly NotImplementedErrors.</p>"},{"location":"dev/task_schema/tests/test_anniecarolanew_plugin/","title":"test_anniecarolanew_plugin","text":""},{"location":"dev/task_schema/tests/test_anniecarolanew_plugin/#test_anniecarolanew_plugin","title":"<code>test_anniecarolanew_plugin</code>","text":""},{"location":"dev/task_schema/tests/test_anniecarolanew_plugin/#tests.test_anniecarolanew_plugin","title":"test_anniecarolanew_plugin","text":"<p>Classes:</p> <ul> <li> <code>AnniecarolaPluginTests</code>           \u2013            <p>This class will run different tests to</p> </li> </ul>"},{"location":"dev/task_schema/tests/test_anniecarolanew_plugin/#tests.test_anniecarolanew_plugin.AnniecarolaPluginTests","title":"AnniecarolaPluginTests","text":"<p>This class will run different tests to check that the class ShotgridPlugin works as it is intended to work.</p> <p>Methods:</p> <ul> <li> <code>setUpClass</code>             \u2013              <p>Looks for errors while instantiating,</p> </li> </ul>"},{"location":"dev/task_schema/tests/test_anniecarolanew_plugin/#tests.test_anniecarolanew_plugin.AnniecarolaPluginTests.setUpClass","title":"setUpClass  <code>classmethod</code>","text":"<pre><code>setUpClass()\n</code></pre> <p>Looks for errors while instantiating, mostly NotImplementedErrors.</p>"},{"location":"dev/task_schema/tests/test_base_plugin/","title":"test_base_plugin","text":""},{"location":"dev/task_schema/tests/test_base_plugin/#test_base_plugin","title":"<code>test_base_plugin</code>","text":""},{"location":"dev/task_schema/tests/test_base_plugin/#tests.test_base_plugin","title":"test_base_plugin","text":"<p>Classes:</p> <ul> <li> <code>BasePluginTests</code>           \u2013            <p>This class will run different tests to</p> </li> </ul>"},{"location":"dev/task_schema/tests/test_base_plugin/#tests.test_base_plugin.BasePluginTests","title":"BasePluginTests","text":"<p>This class will run different tests to check that the class BasePlugin works as it is intended to work.</p>"},{"location":"dev/task_schema/tests/test_google_plugin/","title":"test_google_plugin","text":""},{"location":"dev/task_schema/tests/test_google_plugin/#test_google_plugin","title":"<code>test_google_plugin</code>","text":""},{"location":"dev/task_schema/tests/test_google_plugin/#tests.test_google_plugin","title":"test_google_plugin","text":"<p>Classes:</p> <ul> <li> <code>GooglePluginTests</code>           \u2013            <p>This class will run different tests to</p> </li> </ul>"},{"location":"dev/task_schema/tests/test_google_plugin/#tests.test_google_plugin.GooglePluginTests","title":"GooglePluginTests","text":"<p>This class will run different tests to check that the class GooglePlugin works as it is intended to work.</p>"},{"location":"dev/task_schema/tests/test_grisu_plugin/","title":"test_grisu_plugin","text":""},{"location":"dev/task_schema/tests/test_grisu_plugin/#test_grisu_plugin","title":"<code>test_grisu_plugin</code>","text":""},{"location":"dev/task_schema/tests/test_grisu_plugin/#tests.test_grisu_plugin","title":"test_grisu_plugin","text":"<p>Classes:</p> <ul> <li> <code>GrisuPluginTests</code>           \u2013            <p>This class will run different tests to</p> </li> </ul>"},{"location":"dev/task_schema/tests/test_grisu_plugin/#tests.test_grisu_plugin.GrisuPluginTests","title":"GrisuPluginTests","text":"<p>This class will run different tests to check that the class GrisuPlugin works as it is intended to work.</p> <p>Methods:</p> <ul> <li> <code>setUpClass</code>             \u2013              <p>Looks for errors while instantiating,</p> </li> </ul>"},{"location":"dev/task_schema/tests/test_grisu_plugin/#tests.test_grisu_plugin.GrisuPluginTests.setUpClass","title":"setUpClass  <code>classmethod</code>","text":"<pre><code>setUpClass()\n</code></pre> <p>Looks for errors while instantiating, mostly NotImplementedErrors.</p>"},{"location":"dev/task_schema/tests/test_shotgrid_plugin/","title":"test_shotgrid_plugin","text":""},{"location":"dev/task_schema/tests/test_shotgrid_plugin/#test_shotgrid_plugin","title":"<code>test_shotgrid_plugin</code>","text":""},{"location":"dev/task_schema/tests/test_shotgrid_plugin/#tests.test_shotgrid_plugin","title":"test_shotgrid_plugin","text":"<p>Classes:</p> <ul> <li> <code>ShotgridPluginTests</code>           \u2013            <p>This class will run different tests to</p> </li> </ul>"},{"location":"dev/task_schema/tests/test_shotgrid_plugin/#tests.test_shotgrid_plugin.ShotgridPluginTests","title":"ShotgridPluginTests","text":"<p>This class will run different tests to check that the class ShotgridPlugin works as it is intended to work.</p>"},{"location":"user/setup/","title":"Introducci\u00f3n","text":""},{"location":"user/setup/#primeros-pasos-con-gwaio","title":"Primeros pasos con GwaIO","text":""},{"location":"user/setup/#requisitos-minimos-del-sistema","title":"Requisitos m\u00ednimos del sistema","text":"<p>Para ejecutar y utilizar GwaIO, el equipo donde est\u00e9 instalado debe cumplir con las especificaciones t\u00e9cnicas m\u00ednimas que se indican a continuaci\u00f3n:  </p> <ul> <li>Windows 10 de 64 bits (versi\u00f3n 21H2) o posterior</li> </ul>"},{"location":"user/setup/#requisitos-adicionales-del-sistema","title":"Requisitos adicionales del sistema","text":"<p>GwaIO integra dentro de s\u00ed funcionalidades de otros programas, los cuales ampl\u00edan el abanico de herramientas disponibles, aunque \u00e9stas no sean necesarias, es recomendable disponer de los siguientes programas para obtener sus las funcionalidades adicionales:\u00a0</p> <ul> <li>RV</li> <li>FFmpeg</li> </ul> <p>Adem\u00e1s, si se quiere utilizar el sistema de sincronizaci\u00f3n que viene incluido con GwaIO, se deber\u00e1 tener montado el recurso compartido que se utilice como carpeta ra\u00edz del proyecto. En Windows no ser\u00e1 necesario ya que se utilizan rutas UNC, pero en Mac y Linux se debe montar el recurso ra\u00edz como disco Samba (SMB). En el caso de que el ordenador est\u00e9 en remoto, se deber\u00e1 acceder a la red a trav\u00e9s de una VPN.</p>"},{"location":"user/setup/#instalacion","title":"Instalaci\u00f3n","text":"<p>GwaIO se distribuye con un instalador. Haciendo doble click sobre el instalador se abrir\u00e1 la interfaz de instalaci\u00f3n del programa: GwaIO se distribuye como una carpeta comprimida dentro de un fichero zip. Dentro de esta carpeta encontramos un archivo \".exe\", el cual ejecuta el programa:</p> <p> </p> <p>Deber\u00e1 seguir los pasos del instalador para disponer del programa. Una vez finalizada la instalaci\u00f3n, se podr\u00e1 abrir GwaIO desde la carpeta de instalaci\u00f3n, o desde el acceso directo creado en el escritorio (Si se habilit\u00f3 la opci\u00f3n en la instalaci\u00f3n). </p> <p>Cuando inicias GwaIO por primera vez, eres presentado con la siguiente interfaz:  </p> <p></p> <p>Como es natural, no tiene ning\u00fan dato cargado todav\u00eda, ya que para poder ver datos tienes que identificarte primero en la app.</p>"},{"location":"user/setup/#ficheros-de-configuracion","title":"Ficheros de configuraci\u00f3n","text":"<p>Actualmente GwaIO actualiza autom\u00e1ticamente dos ficheros que se encuentran en la ruta \"%appdata%\\GwaIO\". Si no existen, se generaran autom\u00e1ticamente. Estos dos archivos son:</p> <ul> <li>./gwaio.env: contiene variables de entorno que GwaIO lee y modifica a trav\u00e9s de una interfaz de f\u00e1cil uso para el usuario. Este fichero puede ser modificado a mano si hace falta.</li> <li>./usercfg.json: contiene datos relativos a la sesion de usuario, como por ejemplo:<ul> <li>\u00daltimos filtros utilizados en el \"Panel de Filtros\"</li> <li>\u00daltimo username y contrase\u00f1a utilizados en el Panel de Login. Nota: la contrase\u00f1a que se guarda est\u00e1 encriptada, de tal manera que abriendo \u00e9ste fichero no revela ning\u00fan dato confidencial.</li> <li>\u00daltimo plugin utilizado.</li> </ul> </li> </ul>"},{"location":"user/setup/#inicializacion-del-proyecto","title":"Inicializaci\u00f3n del proyecto","text":"<p>Una vez identificado como usuario en la aplicaci\u00f3n, ya se puede tener acceso a los proyectos instalados en GwaIO. Para cargar un proyecto, haga clic en el men\u00fa desplegable llamado \"Men\u00fa de Plugins\", el cual se encuentra en la \"Barra de Men\u00fas\" del programa, en la parte superior de la ventana principal. Haga clic en el plugin del proyecto que desea cargar. </p> <p></p> <p>Cuando se inicializa un proyecto, el programa carga el plugin vinculado a este proyecto y a continuaci\u00f3n carga autom\u00e1ticamente tanto las tareas del proyecto en el \"Panel de Tareas\", como las barras de herramientas asociadas al mismo. </p>"},{"location":"user/setup/#espacio-de-trabajo","title":"Espacio de trabajo","text":"<p>La interfaz de usuario se divide en dos paneles principales, el \"Panel de Tareas\" y el \"Panel de Ficheros\". Tiene adem\u00e1s una \"Barra de Men\u00fas\" y una \"Barra de Estatus\". </p> <p></p> <p>Adicionalmente tiene otros paneles y barras de herramientas secundarias con funcionalidades adicionales que se pueden solapar entre s\u00ed, desacoplar de la ventana principal y reacoplar de nuevo, dando la posibilidad de customizar el espacio de trabajo. En los siguientes enlaces se puede encontrar informaci\u00f3n m\u00e1s en profundidad sobre los paneles y toolbars que nos encontramos en el espacio de trabajo. </p> <ul> <li>Paneles</li> <li>Toolbars</li> </ul>"},{"location":"user/setup/#actualizacion","title":"Actualizaci\u00f3n","text":"<p>En caso de que exista una actualizaci\u00f3n del programa, nos aparecer\u00e1 un banner en la intefaz que lo indicar\u00e1.</p> <p></p> <p>Haga clic en el n\u00famero de versi\u00f3n para comenzar la actualizaci\u00f3n de GwaIO. No obstante, las actualizaciones se pueden revisar tambien a trav\u00e9s de la \"Barra de Men\u00fas\". Para ello, haga clic en File &gt; Update GwaIO</p>"},{"location":"user/workflow/","title":"Workflow","text":""},{"location":"user/workflow/#uso","title":"USO","text":"<p>Aseg\u00farese de tener acceso a internet y a su servidor para el correcto funcionamiento del programa. En caso contrario, puede sufrir limitaciones de uso en las utilidades de GwaIO e incluso mal funcionamiento de algunas herramientas. </p>"},{"location":"user/workflow/#comenzar-una-tarea-nueva","title":"Comenzar una tarea nueva","text":"<p>Cuando comience una tarea nueva, aseg\u00farese de que dispone en su sistema local de la \u00faltima versi\u00f3n que exista en el servidor. Para ello, seleccione la tarea correspondiente en el \"Panel de Tareas\" y haga clic en el bot\u00f3n \"Down task sync\" que se encuentra en la Toolbar de sincronizado.  </p> <ul> <li> <p>Si al finalizar el proceso de sincronizado obtiene un fichero de versi\u00f3n, seleccione el archivo deseado y vaya a \"Barra de herramientas del explorador\" y haga clic en el bot\u00f3n -&gt; \"Add version &gt; From selected file\". </p> </li> <li> <p>Si al finalizar el proceso de sincronizado no obtiene ning\u00fan fichero de versi\u00f3n, vaya a la \"Barra de herramientas del explorador\" y haga clic en el bot\u00f3n -&gt; \"Add version &gt; From &lt;\"extensi\u00f3n\"&gt; file\" (&lt;\"extensi\u00f3n\"&gt; es equivalente al formato del archivo de versi\u00f3n que desee). Realizando esta acci\u00f3n se asegurar\u00e1 de generar una versi\u00f3n base con la que empezar a trabajar a partir del \u00faltimo archivo generado en la tarea anterior. En caso de que no exista una versi\u00f3n previa o tarea previa, seleccione la \"Template\" id\u00f3nea para su tarea en la ventana de selecci\u00f3n que se abre cuando se da este caso. </p> </li> </ul>"},{"location":"user/workflow/#finalizar-una-tarea","title":"Finalizar una tarea","text":"<p>Al finalizar una tarea, aseg\u00farese de sincronizar todos los archivos en su servidor y publicar la nueva versi\u00f3n correspondiente en Shotgrid. Para realizar esta acci\u00f3n de una manera id\u00f3nea, se recomienda seguir estos pasos: </p> <ol> <li> <p>Seleccione la tarea finalizada en el \"Panel de Tareas\". </p> </li> <li> <p>Seleccione todos los archivos nuevos que desee sincronizar en el servidor y publicar en Shotgrid. </p> </li> <li> <p>Utilice la \"Panel de Publicado\" para publicar y sincronizar estos ficheros. </p> </li> <li> <p>Adicionalmente, puede sincronizar todos los ficheros en su servidor que no haya sincronizado en el \"Panel de Publicado\" haciendo clic en el bot\u00f3n \"Up task sync\", que se encuentra en la \"Barra de sincronizado\". Si \u00fanicamente desea sincronizar archivos espec\u00edficos, seleccione los archivos espec\u00edficos en el \"Panel de ficheros\" de y haga clic en \"Up sync file\", que se encuentra en la \"Barra de sincronizado\". </p> </li> </ol>"},{"location":"user/interface/panels/","title":"Paneles","text":""},{"location":"user/interface/panels/#paneles-principales","title":"Paneles principales","text":""},{"location":"user/interface/panels/#panel-de-tareas","title":"Panel de Tareas","text":"<p>El \"Panel de Tareas\" muestra la informaci\u00f3n relativa a las tareas creadas para cada proyecto.  Esta informaci\u00f3n se muestra en forma de tabla, donde cada tarea es una fila y cada columna son los datos con los que se pueden filtrar las tareas con los filtros que hay en el \"Panel de Filtros\". Las teclas de control y shift funcionan igual que en el explorador de windows y permite seleccionar varias tareas.  </p> <p></p> <p>Adem\u00e1s, tenemos la funcionalidad de poder usar un buscador r\u00e1pido utilizando el atajo de teclado Ctrl+F sobre el panel de tareas.</p> <p></p>"},{"location":"user/interface/panels/#panel-de-ficheros","title":"Panel de Ficheros","text":"<p>El \"Panel de Ficheros\" muestra los ficheros existentes en el sistema de ficheros local para la tarea que haya seleccionada en el \"Panel de Tareas\". Si no hay ninguna tarea seleccionada, este men\u00fa  muestra el sistema de ficheros de la \u00faltima task seleccionada (o vac\u00edo en el caso de que no se hubiera seleccionado ninguna tarea a\u00fan en la sesi\u00f3n activa). A continuaci\u00f3n, se muestran dos im\u00e1genes:  * La primera imagen muestra el \"Panel de Ficheros\" con ninguna tarea seleccionada</p> <p> </p> <ul> <li>La segunda imagen muestra el \"Panel de Ficheros\" con una tarea seleccionada. Si se seleccionan varias tareas, el \"Panel de Ficheros\" muestra la \u00faltima tarea seleccionada. </li> </ul> <p></p> <p>Adicionalmente el \"Panel de Ficheros\" tiene una barra de navegaci\u00f3n y tres botones:  * Subir: Este boton nos lleva a la carpeta padre del path actual.  * Refrescar: Fuerza un refrescado de los datos que hay en el panel.  * Renombrar: Herramienta para renombrar un archivo seleccionado.</p> <p></p> <p>Si se pone una direcci\u00f3n v\u00e1lida y se pulsa la tecla \"Enter\", el \"Panel de Ficheros\" se actualiza a la ruta escrita. </p>"},{"location":"user/interface/panels/#funciones-adicionales","title":"Funciones adicionales","text":"<p>Este panel tiene funcionalidades similares a la de cualquier explorador de archivos: 1. Haga doble click para abrir un archivo 2. Presione Ctrl+Click para seleccionar varios archivos  3. Presione Alt+Click para seleccionar el conjunto de archivos comprendido entre ambos clics.  4. Arrastre un archivo dentro del panel para copiarlo dentro de la carpeta seleccionada en el explorador de ficheros  5. Seleccione y arrastre un archivo del explorador de ficheros a una ventana externa al programa para moverlo/utilizarlo.  6. Los archivos mal nombrados se muestran con el texto de color rojo. </p>"},{"location":"user/interface/panels/#paneles-secundarios","title":"Paneles secundarios","text":"<p>Los paneles secundarios tambien llamados \"docks\" muestran informaci\u00f3n adicional de las tareas y contienen herramientas de utilidad para facilitar el trabajo. </p> <p> Algunos paneles secundarios agrupados. </p> <p>Estos paneles y barras de herramientas se pueden ocultar, mostrar, agrupar o desacoplar de la interfaz o mover de posici\u00f3n al gusto del usuario: </p> <ul> <li> <p>Si desea convertir un panel en flotante, haga clic en la barra de t\u00edtulo y arrastre el panel a otra ubicaci\u00f3n. Otro m\u00e9todo para desacoplar un panel de forma autom\u00e1tica es hacer doble clic en el t\u00edtulo del panel. </p> </li> <li> <p>Si desea acoplar un panel flotante, haga clic en la barra de t\u00edtulo del panel y arrastre hacia otro panel hacia el borde de la ventana. Otro m\u00e9todo para acoplar un panel de forma autom\u00e1tica es hacer doble clic sobre la barra de t\u00edtulo del panel. </p> </li> <li> <p>Para mostrar/ocultar los paneles, haga clic en View, que se encuentra en la barra de men\u00fa en la parte superior de la ventana, y seleccione o deseleccione los paneles que desee modificar. </p> </li> </ul>"},{"location":"user/interface/panels/#panel-de-configuracion","title":"Panel de Configuraci\u00f3n","text":"<p>En este panel puede ver la informaci\u00f3n de la configuraci\u00f3n del programa. Generalmente no se deber\u00eda editar directamente, ya que se edita autom\u00e1ticamente con el uso del propio programa. </p>"},{"location":"user/interface/panels/#panel-de-filtrado","title":"Panel de Filtrado","text":"<p>Permite al usuario filtrar las tareas visibles en el \"Panel de Tareas\". Hay un filtro por cada columna que aparece en este panel. Los filtros se pueden combinar entre s\u00ed. Cuando un filtro este activo su campo de texto es de color azul. </p> <p> </p> <p>Active la casilla \"is not\" para invertir el filtro. Esta acci\u00f3n hace que se invierta su funcionamiento y nos muestre las tareas que no contengan el texto introducido en el filtro. Esta acci\u00f3n cambia el color del campo del filtro a marr\u00f3n. </p> <p> </p> <p>Haga clic en el icono de la \"x\" situado a la derecha del filtro para borrar por completo el texto. Alternativamente tambi\u00e9n puede el usuario borrarlo manualmente con las herramientas comunes de edici\u00f3n de texto. </p> <p>Los filtros tienen un sistema para autocompletar. Puede a\u00f1adir varios tags de filtro separ\u00e1ndo dichos tags con el signo \";\". </p> <p> </p> <p>Si el usuario activa la casilla \"is not\" y deja vac\u00edo el filtro, el \"Panel de Tareas\" no mostrar\u00e1 ninguna tarea. </p>"},{"location":"user/interface/panels/#panel-de-hilos","title":"Panel de Hilos","text":"<p>Panel t\u00e9cnico donde se muestra el listado de todos los hilos de proceso abiertos, finalizados y a la espera en el programa. No es relevante para el usuario. </p> <p> </p>"},{"location":"user/interface/panels/#panel-de-sincronizacion","title":"Panel de Sincronizaci\u00f3n","text":"<p>Panel t\u00e9cnico donde se muestra el log de los archivos y carpetas sincronizadas. Adem\u00e1s, este panel contiene los mismos botones de sincronizado de la \"Barra de herramientas de sincronizaci\u00f3n\". </p>"},{"location":"user/interface/panels/#panel-de-reproduccion","title":"Panel de Reproducci\u00f3n","text":"<p>Reproductor y visualizador de contenido multimedia. Reproduce el \u00faltimo fichero seleccionado en el \"Panel de Ficheros\". Tambi\u00e9n reproduce la miniatura (si la hay en el sistema de ficheros local) de la \u00faltima tarea seleccionada. </p>"},{"location":"user/interface/panels/#panel-de-syncronizado","title":"Panel de syncronizado","text":"<p>En este panel podemos configurar una serie de filtros para que el sincronizador excluya ciertos ficheros o fuerce a sincronizar algun fichero en concreto, adem\u00e1s se puede limitar la cantidad de archivos a sincronizar.  * Include: Sincroniza unicamente los archivos que contiene el texto del recuadro.  * Exclude: Excluye del sincronizado los archivos que contiene el texto del recuadro.  * Limit: Limita el numero de archivos sincronizados. Este limite se aplica por extensi\u00f3n de los archivos. Es decir, si existe para sincronizar 4 archivos .ma y 4 archivos .mov y ponemos un limite de 2, se sincronizar\u00e1n los 2 \u00faltimos .ma y los dos \u00faltimos .mov.</p> <p> </p>"},{"location":"user/interface/panels/#panel-de-notas","title":"Panel de Notas","text":"<p>Panel que recoge todas las notas que contenga la tarea seleccionada en el \"Panel de Tareas\". Haga clic en una nota o imagen para abrirla en el navegador web. Adicionalmente, en la parte superior del panel se muestra la descripci\u00f3n de la tarea, si la tiene. </p>"},{"location":"user/interface/panels/#panel-de-versiones","title":"Panel de Versiones","text":"<p>Panel que recoge todas las versiones que contenga la tarea seleccionada en el \"Panel de Tareas\".</p>"},{"location":"user/interface/panels/#panel-de-renombrado","title":"Panel de Renombrado","text":"<p>Herramienta de renombrado de archivos en lote. Para a\u00f1adir o quitar archivos del lote que se va a procesar en la herramienta seleccione o deseleccione los archivos que desee en el panel del explorador de ficheros. </p> <p> </p> <ul> <li> <p>Prefix: a\u00f1ade el texto escrito en este campo al comienzo del nombre de todos los archivos seleccionados. </p> </li> <li> <p>Suffix: a\u00f1ade el texto escrito en este campo al final del nombre de todos los archivos seleccionados. </p> </li> <li> <p>Delete: elimina del nombre de los archivos seleccionados el texto escrito en el campo. </p> </li> <li> <p>Replace: reemplaza del nombre de los archivos seleccionados el texto introducido en el campo de la izquierda por el texto introducido en el campo de la derecha. </p> </li> <li> <p>Extension: reemplaza la extensi\u00f3n de los archivos seleccionados por la que se escribe en el campo. </p> </li> </ul>"},{"location":"user/interface/panels/#panel-de-publicado","title":"Panel de Publicado","text":"<p>Herramienta para publicar nuevas versiones en la base de datos del plugin. Adicionalmente trata de sincronizar los archivos locales con los del servidor, y si el plugin tiene habilitada la opci\u00f3n, da la posibilidad de empaquetar automaticamente los archivos seleccionados y subirlos a la base de datos. </p> <p> </p> <p>Existen dos formas de ejecutar la herramienta: </p> <ul> <li> <p>Para publicar archivos espec\u00edficos de una tarea siga estos pasos: </p> </li> <li> <p>Antes de abrir la herramienta, seleccione los ficheros a publicar en el \"Panel de ficheros\". </p> </li> <li> <p>Despu\u00e9s abra la herramienta </p> </li> <li> <p>Para publicar archivos de varias tareas siga estos pasos: </p> </li> <li> <p>Antes de abrir la herramienta, seleccione la tarea a publicar en el \"Panel de tareas\". Despu\u00e9s abra la herramienta. </p> </li> </ul> <p>Una vez abierta la herramienta, se mostrar\u00e1n los ficheros que se van a publicar. Esta herramienta muestra distintos campos de informaci\u00f3n: </p> <ul> <li> <p>En la parte superior se detalla la informaci\u00f3n de la tarea en la que se va a publicar los ficheros seleccionados. </p> </li> <li> <p>Publish: checkbox para activar o desactivar la publicaci\u00f3n de un fichero. Si la casilla est\u00e1 activa, el color del campo es azul y el archivo se publicar\u00e1. Si la casilla est\u00e1 desactivada, el color del campo es blanco y el archivo no se publicar\u00e1. </p> </li> <li> <p>Status Publish: estado actual de la publicaci\u00f3n del archivo.  </p> </li> <li> <p>\"Publish succesful\" indica que el archivo ya ha sido publicado. Los archivos publicados no se pueden volver a publicar. </p> </li> <li> <p>\"N/A\" indica que el archivo no es compatible para ser publicado. </p> </li> <li> <p>\"Not published\" indica que el archivo no ha sido publicado anteriormente. </p> </li> <li> <p>Status Sync: estado actual de la sincronizaci\u00f3n del archivo.  </p> </li> <li> <p>\"Not Synced\" indica que el archivo no ha sido sincronizado en el servidor. </p> </li> <li> <p>\"Sync succesful\" indica que el archivo ya se encuentra sincronizado en el servidor. </p> </li> <li> <p>Thumbnail: previsualizaci\u00f3n del archivo a publicar. </p> </li> <li> <p>Path: nombre del archivo a publicar. </p> </li> <li> <p>En la parte inferior a\u00f1ada la descripci\u00f3n que desee para su versi\u00f3n. </p> </li> <li> <p>Presione el bot\u00f3n \"Publish\" para publicar. Al finalizar el proceso, la ventana se cerrar\u00e1 autom\u00e1ticamente. </p> </li> </ul> <p> </p> <p>Para que la publicaci\u00f3n se pueda realizar, deber\u00e1 rellenar toda la informaci\u00f3n necesaria, en caso de que falte informaci\u00f3n, la interfaz mostrar\u00e1 un borde de color rojo sobre el campo que requiera informaci\u00f3n.</p> <p> </p> <p>Una vez finalizado el proceso de publicaci\u00f3n, aparecer\u00e1 una ventana que nos confirma que el proceso se ha realizado correctamente.</p> <p>NOTA: esta herramienta requiere de acceso a su servidor y de conexi\u00f3n a internet para su correcto funcionamiento. Por favor, aseg\u00farese de que cumple estos requisitos para su uso.</p> <p>NOTA: los archivos publicados en la base de datos no se pueden volver a publicar.</p>"},{"location":"user/interface/panels/#panel-de-concatenar-obsoleto","title":"Panel de Concatenar (Obsoleto)","text":"<p>Herramienta para concatenar m\u00faltiples archivos multimedia en un \u00fanico archivo de video. </p> <p></p> <p>Para a\u00f1adir los archivos con los que la herramienta va a trabajar, haga clic en uno de los tres m\u00e9todos que se encuentran en la parte superior de la ventana. </p> <ul> <li> <p>Add Files from Folder: abre una ventana de selecci\u00f3n de carpetas. A\u00f1ade los archivos que contiene las carpetas seleccionadas en la anterior ventana. </p> </li> <li> <p>Add Files from selected Task: a\u00f1ade todos los archivos que contenga la tarea seleccionada en el panel de Tareas. </p> </li> <li> <p>Add Files from selected Files: a\u00f1ade todos los archivos seleccionados en el panel de explorador de ficheros. </p> </li> </ul> <p>El panel central de la herramienta se compone de dos columnas. La primera muestra un checkbox para activar o desactivar su uso en el proceso de concatenado. Si el checkbox est\u00e1 activo en el archivo, la herramienta usara el fichero. En cambio, si el checkbox est\u00e1 desactivado, la herramienta omitir\u00e1 el archivo durante el proceso de concatenado.  </p> <p>La segunda columna del panel central de la herramienta muestra el nombre de los ficheros importados. </p> <p>En la parte inferior del panel encontramos dos opciones: </p> <ul> <li> <p>Duration image: seleccione los segundos que desee que dure las im\u00e1genes est\u00e1ticas en el video concatenado. </p> </li> <li> <p>Output video: inserte la ruta y nombre de la salida del video final. Haga clic en la carpeta para navegar por el explorador de archivos y seleccionar la carpeta de salida. </p> </li> </ul> <p>Por \u00faltimo, presione el bot\u00f3n generar para empezar el proceso de creaci\u00f3n del video. </p>"},{"location":"user/interface/panels/#panel-de-bdl","title":"Panel de BDL","text":"<p>Herramienta para la creaci\u00f3n por lotes de assets dada una BDL en Shotgrid. </p> <p></p> <p>Este panel tiene 3 botones: </p> <ul> <li> <p>Load XLSX: te permite cargar un archivo xlsx que siga el patr\u00f3n para el cual ha sido dise\u00f1ado el plugin de proyecto. Cuando se carga la BDL, aparece una lista con los assets que se van a crear. </p> </li> <li> <p></p> </li> <li> <p>Las filas en verde indican que ya han sido creados y que existen en la base de datos. </p> </li> <li></li> <li> <p>Las filas en rojo indican que hay alg\u00fan tipo de problema, haciendo doble clic en la fila, se indica que problema hay: </p> </li> <li> <p>Para subsanarlo se tiene que eliminar este fallo de la BDL (xlsx) y cargarlo de nuevo. </p> </li> <li> <p>Upload to SG: sube los assets que no est\u00e9n ni en rojo ni en verde a la base de datos. </p> </li> <li> <p>Upload selected to SG: sube los assets seleccionados y que no est\u00e9n ni en rojo ni en verde a la base de datos. </p> </li> </ul> <p>Nota: Los assets que est\u00e9n en verde y que se intenten subir actualizar\u00e1n algunos datos, en el caso de que se aplique y en el case de que algunos datos no sean iguales en el XLSX y en la base de datos. Generalmente esto se aplica a la columna de Description. </p>"},{"location":"user/interface/panels/#panel-de-edl","title":"Panel de EDL","text":"<p>Herramienta para la creaci\u00f3n por lotes de shots en Shotgrid dado un fichero EDL. En esta ventana nos encontraremos 5 botones.</p> <p></p> <ul> <li>LOAD EDL/XML: Este bot\u00f3n permite a\u00f1adir los datos necesarios para poder trabajar con la herramienta:</li> <li>1.- Seleccione el archivo EDL.</li> <li></li> <li>2.- Seleccione el archivo de video correspondiente a la EDL.</li> <li></li> <li>3.- Seleccione el episode/sequence con la que quiere trabajar.</li> <li></li> <li>4.- Seleccione la tarea en la que quiere trabajar.</li> <li></li> <li>5.- Una vez realizados todos los pasos tendremos la informaci\u00f3n en la ventana:</li> <li></li> <li>Split video: Con los datos cargados, podemos utilizar esta bot\u00f3n para recortar los shots del video dado. A trav\u00e9s de los datos de la EDL GwaIO recortar\u00e1 los shots seleccionados en la ventana y los guardar\u00e1 en formato mov y wav.</li> <li>Copy files to server: Copia los archivos generados con el \"Split video\" al servidor.</li> <li>Upload to SG: Genera los shots en Shotgrid si no existen y sube los videos recortados en la tarea seleccionada.</li> </ul>"},{"location":"user/interface/panels/#panel-de-timelog","title":"Panel de Timelog","text":"<p>Este panel sirve para marcar el timelog de la task seleccionada en Shotgrid.</p> <p></p>"},{"location":"user/interface/panels/#tools","title":"Tools","text":""},{"location":"user/interface/panels/#tool-download-playlist-version","title":"Tool Download playlist version","text":"<p>Herramienta para descargar los archivos de las versiones que contenga una Playlist de Shotgrid. </p> <p></p> <ol> <li> <p>Select Playlist: seleccione la playlist de la que quiere descargar las versiones. </p> </li> <li> <p>Output folder: seleccione la carpeta donde quiera guardar los archivos de la descarga. </p> </li> <li> <p>Generate edit with download files: seleccione esta opci\u00f3n si desea hacer un video concatenando todos los archivos descargados. </p> </li> <li> <p>Haga clic en el bot\u00f3n \"Download\" para comenzar el proceso </p> </li> </ol>"},{"location":"user/interface/panels/#tool-download-package","title":"Tool Download Package","text":"<p>Ventana que nos muestra el listado de packages publicados en shotgrid. Esta ventana nos permite filtrar por nombre en caso de que deseemos un package en especifico. Esta herramienta nos descargar\u00e1 y ordenara en su ubicaci\u00f3n correspondiente todos los archivos contenidos en el Package.</p>"},{"location":"user/interface/panels/#tool-job-manager-experimental","title":"Tool Job Manager (Experimental)","text":"<p>Herramienta en fase de desarrollo con la que gestionar los jobs que se envian miendiante la \"Toolbar de Jobs\". En este panel encontraremos la informaci\u00f3n de cada uno de los jobs que tenemos en la farm nativa de GwaIO</p> <p>Para acceder a esta herramienta haga clic en menu de la \"Barra de Menus\" View &gt; Job Viewer</p>"},{"location":"user/interface/panels/#tool-broker-experimental","title":"Tool Broker (Experimental)","text":"<p>La herramienta de Broker simplemente se usa para activar el pc como un nodo de trabajo en la farm de GwaIO. Una vez activa la tool en el pc, comenzar\u00e1 a realizar las tareas que se encuentren en la \"Tool Job Manager\".</p> <p>Para acceder a esta herramienta haga clic en menu de la \"Barra de Menus\" View &gt; Brocker Dock</p>"},{"location":"user/interface/panels/#toolbar-de-jobs","title":"Toolbar de Jobs","text":"<p>Esta toolbar contiene botones con los que abrir el lanzador de jobs a la farm interna de GwaIO. Los componentes de esta toolbar depender\u00e1n del proyecto y de las necesidades que tenga.</p>"},{"location":"user/interface/panels/#tool-launch-job","title":"Tool Launch Job","text":"<p>Esta herramienta se abre mediante los botones que contiene la \"Toolbar de Jobs\". Haga clic en el launcher deseado y a continuaci\u00f3n se mostrara esta ventana:</p> <p></p> <p>La herramienta de Launch Job se compone de una serie de opciones para poder configurar nuestro job:</p> <ul> <li>Seleccione el tipo de job que desea lanzar a farm</li> <li>Si es necesario, seleccione el archivo de input que requiere el job. Alternativamente, puede seleccionar el archivo en el \"Panel de explorardor\" previamente a abrir la herramienta.</li> <li>Si lo desea, puede guardar un preset con la configuraci\u00f3n del job para posteriormente poder seleccionar el preset deseado y no tener que configurar los valores a mano.</li> <li>Configure las opciones con los parametros deseados.</li> <li>Puede usar tags para automatizar el valor deseado en funcion a los valores de la tarea/proyecto. Por ejemplo, puede utilizar el tag de  para seleccionar el valor de duraci\u00f3n que contiene la tarea.</li> <li>Para ver el listado de tags haga clic en el bot\u00f3n de la derecha de cada opci\u00f3n.</li> <li>Para previsualizar el resultado del tag mantenga el rat\u00f3n sobre el boton de tags</li> <li>Para ver la descripci\u00f3n de cualquier parametro mantenga el rat\u00f3n sobre el cuadro de texto del valor del parametro.</li> <li>Por \u00faltimo, haga clic en \"Create Job\" para lanzar el job a la farm.</li> </ul>"},{"location":"user/interface/toolbars/","title":"Toolbars","text":""},{"location":"user/interface/toolbars/#barra-de-menus","title":"Barra de Menus","text":"<p>La \"Barra de Menus\" se sit\u00faa en la parte superior de la aplicaci\u00f3n y tiene la siguiente disposici\u00f3n: </p> <p></p> <ul> <li>File: contiene tres acciones: </li> <li>Update GwaIO: cuando haya alguna actualizaci\u00f3n de GwaIO se deber\u00e1 pulsar este bot\u00f3n para obtenerla. </li> <li>Remove empty folders: elimina directorios vac\u00edos que existan dentro del proyecto. </li> <li>Manage enviroments: abre una ventana para editar las variables de entorno de los proyectos. </li> <li>View: activa o desactiva la visibilidad de paneles. </li> <li>Plugins: inicializa el plugin seleccionado. Solo se puede inicializar un plugin a la vez. </li> <li>&lt;\"Nombre del Proyecto\"&gt;: activa o desactiva las \"Barras de herramientas\" de cada proyecto. </li> <li>Apps: abre aplicaciones de trabajo desde GwaIO. </li> <li>Help: muestra el dialogo de ayuda, hasta la fecha s\u00f3lo tiene un \"About\". </li> </ul>"},{"location":"user/interface/toolbars/#barra-de-estado","title":"Barra de Estado","text":"<p>Muestra diversos mensajes dependiendo de cu\u00e1l sea la \u00faltima acci\u00f3n hecha por el artista.  </p>"},{"location":"user/interface/toolbars/#barras-de-herramientas","title":"Barras de herramientas","text":"<p>Las barras de herramientas, tambi\u00e9n conocidas como \"toolbars\" se pueden ocultar, mostrar, desacoplar de la interfaz o mover de posici\u00f3n al gusto del usuario. Cada una de estas barras de herramientas contienen bonotes con funcionalidades que se describen a continuaci\u00f3n. </p> <p></p> <p>Algunas barras de herramientas (Toolbars). </p> <p>Para mostrar u ocultar las barras de herramientas, haga clic en \"Toolbars\" y/o &lt;\"Nombre del proyecto\"&gt;, que se encuentra en la barra de menus, en la parte superior de la ventana, y seleccione o deseleccione las barras de herramientas que desee modificar. </p>"},{"location":"user/interface/toolbars/#barra-de-herramientas-del-explorador","title":"Barra de herramientas del explorador","text":"Icono Nombre del bot\u00f3n Acci\u00f3n Open local folder Abre la carpeta local de la tarea seleccionada. Esto es, la carpeta de la tarea dentro del sistema de ficheros local del ordenador que est\u00e1 ejecutando la aplicaci\u00f3n. Open server folder Abre la carpeta del servidor de la tarea seleccionada. Esto es, la carpeta de la tarea dentro del sistema de ficheros del servidor que est\u00e1 ejecutando la aplicaci\u00f3n. Si el ordenador est\u00e1 en remoto, necesitar\u00e1 una VPN para acceder a esta carpeta. Add version Crea un nuevo fichero para la tarea seleccionada. El n\u00famero de version elegido se calcula como una unidad superior a la mayor versi\u00f3n encontrada en el sistema de ficheros local. Tiene varias opciones:  <ul><li>From selected file: Crea una nueva versi\u00f3n en la tarea seleccionada a partir del archivo seleccionado en el explorador de ficheros.</li><li>From &lt;\"extensi\u00f3n\"&gt; file: Crea una nueva versi\u00f3n en la tarea seleccionada de la extensi\u00f3n dada por el submen\u00fa del bot\u00f3n. (&lt;\"extensi\u00f3n\"&gt; es equivalente al formato del archivo de versi\u00f3n que se desee)  </li><li>Cuando no hay ning\u00fan archivo, el programa recoger\u00e1 la \u00faltima versi\u00f3n de la tarea anterior. En caso de no haber tarea anterior o esta tarea no tuviese ning\u00fan archivo, se abrir\u00e1 la carpeta de \"Templates\" asociada a su proyecto.</li></ul> Publish version Abre la ventana de publicador de versiones. Para m\u00e1s informaci\u00f3n consulte el ep\u00edgrafe de \"Di\u00e1logo de Publicaci\u00f3n\". <p>Tiene funcionalidades relacionadas con el manejo de ficheros. Adem\u00e1s, tiene herramientas relacionadas con la publicaci\u00f3n de versiones dentro de una base de datos. </p>"},{"location":"user/interface/toolbars/#barra-de-herramientas-de-sincronizacion","title":"Barra de herramientas de sincronizaci\u00f3n","text":"<p>Tiene funcionalidades relacionadas con la sincronizaci\u00f3n de los sistemas de ficheros local y del servidor.  </p> Icono Nombre del bot\u00f3n Acci\u00f3n Up task sync Sincroniza todos los archivos desde el sistema de ficheros local hacia el sistema de ficheros del servidor de las tareas seleccionadas en el \"Panel de Tareas\" o sincroniza unicamente los ficheros seleccionados en el Panel de ficheros. Down task sync Sincroniza todos los archivos desde el sistema de ficheros del servidor hacia el sistema de ficheros local de las tareas seleccionadas en el \"Panel de Tareas\" o sincroniza unicamente los ficheros seleccionados en el Panel de ficheros. Maya sync Sincroniza las dependencias del archivo maya seleccionado del servidor hacia el sistema de ficheros local."},{"location":"user/interface/toolbars/#barra-de-herramientas-de-reproduccion-obsoleto","title":"Barra de herramientas de reproducci\u00f3n (Obsoleto)","text":"<p>Contiene herramientas relacionadas con la visualizaci\u00f3n y comprobaci\u00f3n de ficheros. </p> Icono Nombre del bot\u00f3n Acci\u00f3n Open in RV Requiere tener instalado el programa RV. Permite previsualizar ficheros dentro del programa RV con distintas opciones:<ul><li>Concat video: abre en RV concatenando los archivos de video seleccionados en el explorador de ficheros. Si no hay ficheros seleccionados, are en RV concatenando el ultimo fichero de video que contenga cada tarea seleccionada en el \"Panel de Tareas\" siempre que no haya archivos seleccionados en el explorador de ficheros.</li><li>Concat image: Abre en RV concatenando los archivos de imagen seleccionados en el \"Panel de ficheros\", si no hay ficheros seleccionados, abre en RV concatenando el ultimo fichero de imagen que contenga cada tarea seleccionada en el \"Panel de Tareas\" siempre que no haya archivos seleccionados en el explorador de ficheros.</li><li>Open concatenator: Abre el \"Panel de concatenar\".</li></ul> Compare in RV Requiere tener instalado el programa RV. Permite comparar ficheros dentro del programa RV con distintas opciones:<ul><li></li><li>Compare video: Abre en RV en modo comparaci\u00f3n los archivos de video seleccionados en el \"Panel de Ficheros\". Si no hay ficheros seleccionados, abre en RV en modo comparaci\u00f3n el ultimo fichero de video que contenga cada tarea seleccionada en el \"Panel de Tareas\".</li><li>Compare images: Abre en RV en modo comparaci\u00f3n los archivos de imagen seleccionados en el \"Panel de Ficheros\". Si no hay ficheros seleccionados, abre en RV en modo comparaci\u00f3n el ultimo fichero de video que contenga cada tarea seleccionada en el \"Panel de Tareas\".</li></ul>"},{"location":"user/interface/toolbars/#barra-de-herramientas-de-sg","title":"Barra de herramientas de SG","text":"<p>Contiene funcionalidades relacionadas con Shotgrid.  </p> Icono Nombre del bot\u00f3n Acci\u00f3n Refresh list of tasks Actualiza la lista de tareas en el \"Panel del Tareas\". Tienes que seleccionar qu\u00e9 tipo de entidad quieres previsualizar: Assets, Episodes, Sequences o Shots.  Open task in shotgrid Abre en el navegador de internet la p\u00e1gina de Shotgrid de la tarea seleccionada en el \"Panel de Tareas\". Open Check BDL Abre el \"Panel de BDL\". Open Download playlist version Abre el \"Panel de descarga de listas de reproducci\u00f3n\". Upload Package Sube a la base de datos de Shotgrid los archivos seleccionados en el \"Panel de ficheros\". Download Package Descarga al sistema de ficheros local el ultimo package de los archivos que hay subido a Shotgrid de la tarea seleccionada en el \"Panel de tareas\". Como alternativa, podemos abrir la \"Tool Download Package\". Open EDL Abre el \"Panel de EDL\". Open Timelog Abre el \"Panel de Timelog\". Open RV Abre RV concatenando los shots previos y posteriores a la task seleccionada. Para usar este bot\u00f3n, seleccione una task de animaci\u00f3n y apriete el boton \"Open RV\", seleccione el paddin con la cantidad de videos anteriores y posteriores."}]}